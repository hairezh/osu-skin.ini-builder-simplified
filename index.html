<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>skin.ini studio (v3)</title>
  <link rel="icon" type="image/png" href="https://i.pinimg.com/1200x/d6/ca/e4/d6cae471e8471dec46c4304104adb4b1.jpg"/>

  <style>
    :root{
      --bg0:#06070a;
      --bg1:#0b0c10;
      --fg:#e9e9ee;
      --muted:rgba(233,233,238,.55);
      --muted2:rgba(233,233,238,.40);
      --border:rgba(255,255,255,.10);
      --panel:rgba(255,255,255,.04);
      --panel2:rgba(0,0,0,.25);
      --accent:rgba(166, 255, 233, .9);
      --danger:rgba(255,120,120,.9);

      --r:12px;
      --fs:14px;
      --lh:1.55;

      --sideW: 260px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }

    /* ===== Background bonitinho ===== */
    body{
      margin:0;
      color:var(--fg);
      font:var(--fs)/var(--lh) ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      background:
        radial-gradient(1000px 600px at 10% 10%, rgba(140,120,255,.18), transparent 60%),
        radial-gradient(900px 650px at 90% 20%, rgba(120,255,214,.14), transparent 55%),
        radial-gradient(900px 700px at 55% 95%, rgba(255,160,120,.10), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      overflow:hidden;
    }

    /* textura sutil */
    body::before{
      content:"";
      position:fixed; inset:0;
      pointer-events:none;
      background-image:
        radial-gradient(circle at 20% 30%, rgba(255,255,255,.035) 0 1px, transparent 2px),
        radial-gradient(circle at 80% 70%, rgba(255,255,255,.030) 0 1px, transparent 2px),
        radial-gradient(circle at 40% 80%, rgba(255,255,255,.025) 0 1px, transparent 2px);
      background-size: 260px 260px, 320px 320px, 420px 420px;
      filter: blur(.2px);
      opacity:.9;
      animation: drift 18s linear infinite;
    }
    @keyframes drift{
      0%{ transform: translate3d(0,0,0); }
      100%{ transform: translate3d(-60px, -40px, 0); }
    }

    /* Scrollbar */
    *{
      scrollbar-width: thin;
      scrollbar-color: rgba(220,220,230,.30) rgba(0,0,0,.18);
    }
    *::-webkit-scrollbar{ width:10px; height:10px; }
    *::-webkit-scrollbar-track{ background: rgba(0,0,0,.18); border-radius: 10px; }
    *::-webkit-scrollbar-thumb{
      background: rgba(220,220,230,.28);
      border: 2px solid rgba(0,0,0,.18);
      border-radius: 10px;
    }
    *::-webkit-scrollbar-thumb:hover{ background: rgba(220,220,230,.42); }

    /* ===== App layout ===== */
    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      position:relative;
      z-index:1;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      background:linear-gradient(180deg, rgba(0,0,0,.45), rgba(0,0,0,.20));
      backdrop-filter: blur(10px);
    }

    .brand{
      display:flex; align-items:baseline; gap:10px; flex-wrap:wrap;
    }
    .brand h1{
      margin:0;
      font-size:14px;
      letter-spacing:.2px;
      font-weight:900;
    }
    .brand .tag{
      font-size:12px;
      color:var(--muted2);
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.22);
      border-radius:999px;
      padding:2px 10px;
    }

    .layout{
      flex:1; min-height:0;
      display:grid;
      grid-template-columns: var(--sideW) 1fr;
      overflow:hidden;
    }

    .sidebar{
      min-height:0;
      border-right:1px solid var(--border);
      background:linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.10));
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:auto;
    }

    .main{
      min-height:0;
      padding:10px;
      display:grid;
      grid-template-columns: 1.12fr .88fr;
      gap:10px;
      overflow:hidden;
    }

    .card{
      border:1px solid var(--border);
      background:rgba(255,255,255,.03);
      border-radius:var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-height:0;
      display:flex;
      flex-direction:column;
    }
    .cardHead{
      padding:10px 10px 8px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      border-bottom:1px solid var(--border);
      background:rgba(0,0,0,.18);
      flex-wrap:wrap;
    }
    .cardBody{
      padding:10px;
      overflow:auto;
      min-height:0;
      flex:1;
    }

    .group{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.14);
      border-radius:14px;
      overflow:hidden;
    }
    .groupHead{
      padding:10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      color:rgba(233,233,238,.78);
      font-weight:900;
      font-size:12px;
      letter-spacing:.2px;
      background:rgba(0,0,0,.18);
    }
    .groupBody{
      padding:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .tabs{ display:flex; flex-direction:column; gap:8px; }
    .tab{
      cursor:pointer;
      padding:10px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.18);
      color:rgba(233,233,238,.62);
      font-weight:900;
      user-select:none;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      transition:140ms linear;
    }
    .tab:hover{
      color:rgba(233,233,238,.95);
      border-color:rgba(255,255,255,.16);
      background:rgba(255,255,255,.04);
    }
    .tab.active{
      color:rgba(233,233,238,.95);
      border-color:rgba(255,255,255,.18);
      background:rgba(255,255,255,.06);
    }
    .mini{ font-size:12px; color:var(--muted2); }

    .btn{
      cursor:pointer;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.22);
      color:rgba(233,233,238,.70);
      font-weight:800;
      transition:140ms linear;
      user-select:none;
    }
    .btn:hover{
      color:rgba(233,233,238,.95);
      border-color:rgba(255,255,255,.18);
      background:rgba(255,255,255,.05);
    }
    .btn.primary{
      background:rgba(255,255,255,.08);
      color:rgba(233,233,238,.95);
      border-color:rgba(255,255,255,.16);
    }
    .btn.danger:hover{
      border-color:rgba(255,140,140,.35);
      color:rgba(255,210,210,.95);
    }

    .pill{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.16);
      color:rgba(233,233,238,.60);
      font-size:12px;
      font-weight:800;
    }
    .sep{ height:1px; background:rgba(255,255,255,.10); margin:10px 0; }

    .row{
      display:grid;
      grid-template-columns: 210px 1fr;
      gap:10px;
      align-items:center;
      margin-bottom:8px;
    }
    .row label{
      font-size:12px;
      color:rgba(233,233,238,.76);
      font-weight:800;
    }
    input[type="text"], input[type="number"], select, textarea{
      width:100%;
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      background:rgba(0,0,0,.22);
      color:rgba(233,233,238,.95);
      padding:8px 10px;
      outline:none;
      font:inherit;
    }
    textarea{ min-height: calc(100vh - 220px); resize:none; }

    input[type="color"]{
      width:46px; height:36px;
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      background:transparent;
      padding:0;
    }
    .inline{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }

    /* Switch */
    .switch{ display:inline-flex; align-items:center; gap:8px; }
    .switch input{ display:none; }
    .sw{
      width:46px; height:26px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.22);
      border-radius:10px;
      position:relative;
      transition:140ms linear;
      flex:0 0 auto;
    }
    .sw::after{
      content:"";
      width:20px; height:20px;
      position:absolute; top:50%; left:3px;
      transform:translateY(-50%);
      border-radius:8px;
      background:rgba(255,255,255,.25);
      transition:140ms linear;
    }
    .switch input:checked + .sw{
      border-color:rgba(255,255,255,.18);
      background:rgba(255,255,255,.06);
    }
    .switch input:checked + .sw::after{
      left:23px;
      background:rgba(166,255,233,.75);
      box-shadow: 0 0 0 2px rgba(166,255,233,.14);
    }

    /* Accordion blocks */
    .block{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.015);
      border-radius:14px;
      overflow:hidden;
      margin:10px 0;
    }
    .blockHead{
      width:100%;
      border:0;
      cursor:pointer;
      padding:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      background:rgba(0,0,0,.18);
      color:rgba(233,233,238,.95);
      text-align:left;
      font:inherit;
      font-weight:900;
    }
    .caret{ color:rgba(233,233,238,.55); transition:140ms linear; }
    .block.open .caret{ transform: rotate(90deg); }
    .blockBody{
      display:none;
      padding:10px;
      border-top:1px solid rgba(255,255,255,.08);
    }
    .block.open .blockBody{ display:block; }

    /* Keymode toggles */
    .kmTools{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:8px; }
    .kmWrap{ display:flex; flex-wrap:wrap; gap:10px; }
    .kmPill{
      display:flex;
      align-items:center;
      gap:10px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.16);
      font-size:12px;
      font-weight:900;
      color:rgba(233,233,238,.65);
    }
    .kmPill.on{
      color:rgba(233,233,238,.95);
      border-color:rgba(255,255,255,.18);
      background:rgba(255,255,255,.06);
    }

    /* Preview area */
    .previewTools{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .badge{
      font-size:12px;
      padding:4px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.18);
      color:rgba(233,233,238,.65);
      font-weight:900;
    }

    /* Music controls */
    .music{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .slider{
      display:flex; align-items:center; gap:8px;
      font-size:12px; color:var(--muted);
      font-weight:800;
    }
    .slider input[type="range"]{ width:120px; }

    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      .sidebar{ border-right:0; border-bottom:1px solid var(--border); }
      .main{ grid-template-columns: 1fr; }
      textarea{ min-height: 50vh; }
    }
  </style>
</head>

<body>
  <div class="app">

    <div class="topbar">
      <div class="brand">
        <h1>skin.ini studio</h1>
        <span class="tag">v3 • import/export • catch + mania • taiko info</span>
      </div>

      <div class="music">
        <button class="btn" id="musicToggle">▶ ambient</button>
        <div class="slider">
          <span>vol</span>
          <input type="range" id="musicVol" min="0" max="1" step="0.01" value="0.18">
        </div>
      </div>
    </div>

    <div class="layout">
      <aside class="sidebar">

        <div class="group">
          <div class="groupHead">Seções</div>
          <div class="groupBody">
            <div class="tabs" id="tabs"></div>
            <div class="mini">Troca rápida entre painéis. Importa/Exporta no preview.</div>
          </div>
        </div>

        <div class="group">
          <div class="groupHead">Export / Import</div>
          <div class="groupBody">
            <button class="btn primary" id="downloadIni">Download skin.ini</button>
            <button class="btn" id="copyIni">Copiar preview</button>
            <button class="btn" id="importOpen">Importar (colar)</button>
            <button class="btn danger" id="wipeAll">Reset total</button>
            <div class="sep"></div>
            <div class="pill"><span>auto-save</span><span id="savePulse">—</span></div>
          </div>
        </div>

        <div class="group">
          <div class="groupHead">Opções de geração</div>
          <div class="groupBody">
            <div class="pill">
              <span>formatação alinhada</span>
              <label class="switch" title="Alinha chaves e espaça grupos">
                <input type="checkbox" id="pretty" checked>
                <span class="sw"></span>
              </label>
            </div>

            <div class="pill">
              <span>comentar vazios</span>
              <label class="switch" title="Se ligado, linhas vazias viram //Key:">
                <input type="checkbox" id="commentEmpty">
                <span class="sw"></span>
              </label>
            </div>

            <div class="pill">
              <span>versão do skin.ini</span>
              <select id="versionPick" style="max-width:140px">
                <option value="2.0">2.0</option>
                <option value="2.1">2.1</option>
                <option value="2.2">2.2</option>
                <option value="2.3">2.3</option>
                <option value="2.4">2.4</option>
                <option value="2.5">2.5</option>
                <option value="2.6">2.6</option>
                <option value="2.7">2.7</option>
                <option value="latest" selected>latest</option>
              </select>
            </div>

            <div class="mini">
              Dica: “Taiko” não tem seção no skin.ini (é por arquivos). :contentReference[oaicite:3]{index=3}
            </div>
          </div>
        </div>

      </aside>

      <main class="main">
        <div class="card">
          <div class="cardHead">
            <div class="mini" id="panelHint">Editor</div>
            <span class="badge" id="statusBadge">ok</span>
          </div>
          <div class="cardBody" id="panel"></div>
        </div>

        <div class="card">
          <div class="cardHead">
            <div class="mini">Preview do skin.ini</div>
            <div class="previewTools">
              <button class="btn" id="refresh">Atualizar</button>
            </div>
          </div>
          <div class="cardBody">
            <textarea id="preview" readonly></textarea>
          </div>
        </div>
      </main>
    </div>
  </div>

  <!-- Modal de import -->
  <dialog id="importDlg" style="max-width:900px;width:calc(100% - 24px);border:1px solid rgba(255,255,255,.14);border-radius:16px;background:rgba(0,0,0,.88);color:rgba(233,233,238,.95);box-shadow:0 20px 60px rgba(0,0,0,.55);">
    <form method="dialog" style="margin:0;padding:12px;">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;">
        <div style="font-weight:900;">Importar skin.ini (colar texto)</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;">
          <button class="btn" value="cancel">Fechar</button>
          <button class="btn primary" id="importApply" value="default" type="button">Aplicar import</button>
        </div>
      </div>
      <div style="height:10px"></div>
      <textarea id="importArea" style="min-height:45vh;"></textarea>
      <div style="height:8px"></div>
      <div class="mini">
        Import tenta ler chaves conhecidas do skin.ini e preencher os campos. Linhas desconhecidas são ignoradas.
      </div>
    </form>
  </dialog>

<script>
/* ===========================
   skin.ini studio v3
   - UI gerada por “schema” (mais escalável)
   - Import/export
   - Catch + Mania mais completa
   - Música: WebAudio (sem copyright), play/pause + volume
   - Taiko: aba informativa (não existe [Taiko] no skin.ini)
=========================== */

const $ = (id)=>document.getElementById(id);

const STORAGE_KEY = "skinini_studio_v3_state";

/* ---------- util ---------- */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const bool01 = (b)=> (b ? "1" : "0");

function cleanLine(s){ return String(s ?? "").replace(/\r/g,"").trimEnd(); }
function isBlank(v){ return cleanLine(v) === ""; }

function debounce(fn, wait){
  let t=null;
  return (...args)=>{
    clearTimeout(t);
    t=setTimeout(()=>fn(...args), wait);
  };
}

function rgbToHex(rgb){
  const m = String(rgb||"").match(/^\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*$/);
  if(!m) return null;
  const r = clamp(parseInt(m[1],10),0,255);
  const g = clamp(parseInt(m[2],10),0,255);
  const b = clamp(parseInt(m[3],10),0,255);
  return "#" + [r,g,b].map(x=>x.toString(16).padStart(2,"0")).join("");
}
function hexToRgb(hex){
  const h = String(hex||"").replace("#","").trim();
  if(!/^[0-9a-fA-F]{6}$/.test(h)) return "";
  const r = parseInt(h.slice(0,2),16);
  const g = parseInt(h.slice(2,4),16);
  const b = parseInt(h.slice(4,6),16);
  return `${r},${g},${b}`;
}

function numOr(v, fallback){
  const n = Number(String(v ?? "").trim());
  return Number.isFinite(n) ? n : fallback;
}
function intOr(v, fallback){
  const n = parseInt(String(v ?? "").trim(), 10);
  return Number.isFinite(n) ? n : fallback;
}

function fmtKV(key, value){
  const v = cleanLine(value);
  if(state.pretty){
    const k = String(key).padEnd(32, " ");
    return `${k} : ${v}`;
  }
  return `${key}: ${v}`;
}

function pushKV(lines, key, value){
  const v = cleanLine(value);
  if(v !== ""){
    lines.push(fmtKV(key, v));
    return;
  }
  if(state.commentEmpty){
    if(state.pretty){
      const k = String(key).padEnd(32, " ");
      lines.push(`// ${k} :`);
    }else{
      lines.push(`//${key}:`);
    }
  }
}

function spacer(lines){ if(state.pretty) lines.push(""); }
function header(lines, title){
  if(state.pretty){
    lines.push(`// ${title} --`);
    lines.push("");
  }
}

/* ---------- state ---------- */
const ALL_MANIA_KEYS = Array.from({length: 18}, (_,i)=>i+1);

function defaultManiaMode(keys){
  return {
    // layout
    ColumnStart: "",
    ColumnRight: "",
    ColumnSpacing: "0",
    ColumnWidth: "70",
    ColumnLineWidth: "",

    // gameplay
    BarlineHeight: "",
    LightingNWidth: "",
    LightingLWidth: "",
    WidthForNoteHeightScale: "",
    HitPosition: "",
    LightPosition: "",
    ComboPosition: "",
    ScorePosition: "",
    JudgementLine: true,

    // misc
    LightFramePerSecond: "",
    SpecialStyle: "",
    ComboBurstStyle: "",
    SplitStages: "",
    StageSeparation: "",
    SeparateScore: "",
    KeysUnderNotes: false,
    UpsideDown: false,
    KeyFlipWhenUpsideDown: "",
    NoteFlipWhenUpsideDown: "",
    NoteBodyStyle: "",

    // stage/lighting (numeric/string)
    StageLeft: "",
    StageRight: "",
    StageBottom: "",
    StageHint: "",
    StageLight: "",
    LightingN: "",
    LightingL: "",

    // colours per keymode
    ColourColumnLine: "",
    ColourBarline: "",
    ColourJudgementLine: "",
    ColourKeyWarning: "",
    ColourHold: "",
    ColourBreak: "",
    ColourLight: {}, // ColourLight0..n
    Colour: {},      // Colour0..n

    // patterns (filenames)
    KeyImage: "",
    KeyImageD: "",
    NoteImage: "",
    NoteImageH: "",
    NoteImageL: "",
    NoteImageT: "",
    WarningArrow: "",

    // hitbursts
    Hit0: "",
    Hit50: "",
    Hit100: "",
    Hit200: "",
    Hit300: "",
    Hit300g: "",
  };
}

const state = {
  pretty: true,
  commentEmpty: false,
  version: "latest",

  activeTab: "general",

  // [General]
  general: {
    Name: "",
    Author: "",
    AnimationFramerate: "",
    AllowSliderBallTint: true,
    ComboBurstRandom: "",
    CursorCentre: true,
    CursorExpand: false,
    CursorRotate: false,
    CursorTrailRotate: false,
    CustomComboBurstSounds: "",
    HitCircleOverlayAboveNumber: false,
    LayeredHitSounds: true,
    SliderBallFlip: false,
    SpinnerFadePlayfield: true,
    SpinnerFrequencyModulate: "",
    SpinnerNoBlink: false,
  },

  // [Colours]
  colours: {
    Combo1: "",
    Combo2: "",
    Combo3: "",
    Combo4: "",
    Combo5: "",
    Combo6: "",
    Combo7: "",
    Combo8: "",
    InputOverlayText: "",
    MenuGlow: "",
    SliderBall: "",
    SliderBorder: "",
    SliderTrackOverride: "",
    SongSelectActiveText: "",
    SongSelectInactiveText: "",
    SpinnerBackground: "",
    StarBreakAdditive: "",
  },

  // [Fonts]
  fonts: {
    HitCirclePrefix: "",
    HitCircleOverlap: "",
    ScorePrefix: "",
    ScoreOverlap: "",
    ComboPrefix: "",
    ComboOverlap: "",
  },

  // [CatchTheBeat]
  catch: {
    HyperDash: "",
    HyperDashFruit: "",
    HyperDashAfterImage: "",
  },

  // [Mania] shared
  maniaShared: {
    enabled: Object.fromEntries(ALL_MANIA_KEYS.map(k => [k, k===4])),
    open: Object.fromEntries(ALL_MANIA_KEYS.map(k => [k, k===4])),
    search: "",
  },

  mania: Object.fromEntries(ALL_MANIA_KEYS.map(k => [k, defaultManiaMode(k)])),
};

/* ---------- schema UI (gera campos) ---------- */

function uiRowText(label, path, placeholder=""){
  const id = pathToId(path);
  return `
    <div class="row">
      <label for="${id}">${label}</label>
      <input type="text" id="${id}" data-path="${path}" placeholder="${escapeHtml(placeholder)}">
    </div>
  `;
}
function uiRowNum(label, path, placeholder=""){
  const id = pathToId(path);
  return `
    <div class="row">
      <label for="${id}">${label}</label>
      <input type="number" id="${id}" data-path="${path}" placeholder="${escapeHtml(placeholder)}">
    </div>
  `;
}
function uiRowBool(label, path){
  const id = pathToId(path);
  return `
    <div class="row">
      <label>${label}</label>
      <div class="inline">
        <label class="switch">
          <input type="checkbox" id="${id}" data-path="${path}">
          <span class="sw"></span>
        </label>
      </div>
    </div>
  `;
}
function uiRowColor(label, path){
  const id = pathToId(path);
  const pickId = id + "_pick";
  return `
    <div class="row">
      <label>${label}</label>
      <div class="inline">
        <input type="color" id="${pickId}" data-pick-for="${id}">
        <input type="text" id="${id}" data-path="${path}" placeholder="255,255,255">
      </div>
    </div>
  `;
}
function uiNote(text){
  return `<div class="mini">${text}</div>`;
}

const TABS = [
  { key:"general", title:"General", hint:"Config geral do skin.ini (inclui opções usadas também por standard/taiko/catch).", render: renderGeneral },
  { key:"colours", title:"Colours", hint:"Cores do UI e gameplay (Combo1..8, SliderBorder, etc).", render: renderColours },
  { key:"fonts", title:"Fonts", hint:"Prefixos/overlap (HitCircle/Score/Combo).", render: renderFonts },
  { key:"catch", title:"Catch", hint:"A seção [CatchTheBeat] tem só 3 chaves oficiais.", render: renderCatch },
  { key:"taiko", title:"Taiko (info)", hint:"Taiko é por arquivos/pasta taiko/ — não existe [Taiko] no skin.ini.", render: renderTaikoInfo },
  { key:"mania", title:"Mania", hint:"Editor avançado por keymode (1K..18K).", render: renderMania },
];

/* ---------- helpers state <-> UI ---------- */
function pathToId(path){
  return "p_" + path.replaceAll(".", "__").replaceAll("[","_").replaceAll("]","_");
}
function getByPath(obj, path){
  const parts = path.split(".");
  let cur = obj;
  for(const p of parts){
    if(cur == null) return undefined;
    cur = cur[p];
  }
  return cur;
}
function setByPath(obj, path, value){
  const parts = path.split(".");
  let cur = obj;
  for(let i=0;i<parts.length-1;i++){
    const p = parts[i];
    if(!(p in cur)) cur[p] = {};
    cur = cur[p];
  }
  cur[parts[parts.length-1]] = value;
}

function escapeHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#39;");
}

/* ---------- render tabs ---------- */
function renderTabs(){
  const el = $("tabs");
  el.innerHTML = TABS.map(t => `
    <div class="tab ${state.activeTab===t.key?"active":""}" data-tab="${t.key}">
      <span>${t.title}</span>
      <span class="mini">${t.key==="mania"?"1K..18K":(t.key==="taiko"?"files":"")}</span>
    </div>
  `).join("");

  el.querySelectorAll("[data-tab]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      state.activeTab = btn.dataset.tab;
      saveSoon();
      renderActiveTab();
    });
  });
}

function renderActiveTab(){
  const tab = TABS.find(t => t.key === state.activeTab) || TABS[0];
  $("panelHint").textContent = tab.hint;
  $("statusBadge").textContent = "ok";
  $("panel").innerHTML = tab.render();
  hydrateInputsFromState($("panel"));
  wirePanelListeners($("panel"));
  renderTabs();
}

/* ---------- panel renderers ---------- */
function renderGeneral(){
  return `
    <div class="block open">
      <button class="blockHead" type="button"><span>[General]</span><span class="caret">▸</span></button>
      <div class="blockBody">
        ${uiRowText("Name", "general.Name", "Ex: Minha Skin")}
        ${uiRowText("Author", "general.Author", "Seu nome")}
        <div class="row"><label>Version</label>
          <div class="inline">
            <input type="text" value="${escapeHtml(state.version)}" readonly>
            <span class="mini">usa o seletor na sidebar</span>
          </div>
        </div>

        <div class="sep"></div>
        <div class="mini">Essas chaves aparecem no “Blank skin.ini” oficial. :contentReference[oaicite:4]{index=4}</div>
        ${uiRowNum("AnimationFramerate", "general.AnimationFramerate", "-1 ou fps")}
        ${uiRowBool("AllowSliderBallTint", "general.AllowSliderBallTint")}
        ${uiRowText("ComboBurstRandom", "general.ComboBurstRandom", "0/1")}
        ${uiRowBool("CursorCentre", "general.CursorCentre")}
        ${uiRowBool("CursorExpand", "general.CursorExpand")}
        ${uiRowBool("CursorRotate", "general.CursorRotate")}
        ${uiRowBool("CursorTrailRotate", "general.CursorTrailRotate")}
        ${uiRowText("CustomComboBurstSounds", "general.CustomComboBurstSounds", "ex: 50,75,100")}
        ${uiRowBool("HitCircleOverlayAboveNumber", "general.HitCircleOverlayAboveNumber")}
        ${uiRowBool("LayeredHitSounds", "general.LayeredHitSounds")}
        ${uiRowBool("SliderBallFlip", "general.SliderBallFlip")}
        ${uiRowBool("SpinnerFadePlayfield", "general.SpinnerFadePlayfield")}
        ${uiRowText("SpinnerFrequencyModulate", "general.SpinnerFrequencyModulate", "0/1")}
        ${uiRowBool("SpinnerNoBlink", "general.SpinnerNoBlink")}
      </div>
    </div>
  `;
}

function renderColours(){
  return `
    <div class="block open">
      <button class="blockHead" type="button"><span>[Colours]</span><span class="caret">▸</span></button>
      <div class="blockBody">
        <div class="mini">RGB no formato: <b>r,g,b</b>. (Ex: 255,255,255) :contentReference[oaicite:5]{index=5}</div>

        <div class="sep"></div>
        <div class="mini"><b>Combo colours</b></div>
        <div class="grid2">
          ${uiRowColor("Combo1", "colours.Combo1")}
          ${uiRowColor("Combo2", "colours.Combo2")}
          ${uiRowColor("Combo3", "colours.Combo3")}
          ${uiRowColor("Combo4", "colours.Combo4")}
          ${uiRowColor("Combo5", "colours.Combo5")}
          ${uiRowColor("Combo6", "colours.Combo6")}
          ${uiRowColor("Combo7", "colours.Combo7")}
          ${uiRowColor("Combo8", "colours.Combo8")}
        </div>

        <div class="sep"></div>
        <div class="mini"><b>UI / gameplay</b></div>
        ${uiRowColor("InputOverlayText", "colours.InputOverlayText")}
        ${uiRowColor("MenuGlow", "colours.MenuGlow")}
        ${uiRowColor("SongSelectActiveText", "colours.SongSelectActiveText")}
        ${uiRowColor("SongSelectInactiveText", "colours.SongSelectInactiveText")}
        ${uiRowColor("SliderBall", "colours.SliderBall")}
        ${uiRowColor("SliderBorder", "colours.SliderBorder")}
        ${uiRowColor("SliderTrackOverride", "colours.SliderTrackOverride")}
        ${uiRowColor("SpinnerBackground", "colours.SpinnerBackground")}
        ${uiRowColor("StarBreakAdditive", "colours.StarBreakAdditive")}
      </div>
    </div>
  `;
}

function renderFonts(){
  return `
    <div class="block open">
      <button class="blockHead" type="button"><span>[Fonts]</span><span class="caret">▸</span></button>
      <div class="blockBody">
        <div class="mini">Essas chaves também estão no “Blank skin.ini” oficial. :contentReference[oaicite:6]{index=6}</div>
        <div class="sep"></div>
        <div class="grid2">
          <div>
            ${uiRowText("HitCirclePrefix", "fonts.HitCirclePrefix", "default: default")}
            ${uiRowNum("HitCircleOverlap", "fonts.HitCircleOverlap", "0")}
          </div>
          <div>
            ${uiRowText("ScorePrefix", "fonts.ScorePrefix", "score")}
            ${uiRowNum("ScoreOverlap", "fonts.ScoreOverlap", "0")}
          </div>
        </div>
        <div class="grid2">
          <div>
            ${uiRowText("ComboPrefix", "fonts.ComboPrefix", "combo")}
            ${uiRowNum("ComboOverlap", "fonts.ComboOverlap", "0")}
          </div>
          <div>${uiNote("Dica: overlaps negativos às vezes ajudam com fontes grandes.")}</div>
        </div>
      </div>
    </div>
  `;
}

function renderCatch(){
  return `
    <div class="block open">
      <button class="blockHead" type="button"><span>[CatchTheBeat]</span><span class="caret">▸</span></button>
      <div class="blockBody">
        <div class="mini">Oficialmente, Catch tem só estas 3 chaves no skin.ini. :contentReference[oaicite:7]{index=7}</div>
        <div class="sep"></div>
        ${uiRowText("HyperDash", "catch.HyperDash", "0/1")}
        ${uiRowText("HyperDashFruit", "catch.HyperDashFruit", "0/1")}
        ${uiRowText("HyperDashAfterImage", "catch.HyperDashAfterImage", "0/1")}
      </div>
    </div>
  `;
}

function renderTaikoInfo(){
  return `
    <div class="block open">
      <button class="blockHead" type="button"><span>Taiko (por arquivos)</span><span class="caret">▸</span></button>
      <div class="blockBody">
        <div class="mini">
          Não existe seção <b>[Taiko]</b> no <b>skin.ini</b>. O Taiko é skinnado por arquivos (e opcionalmente pela pasta <b>taiko/</b>),
          e o jogador precisa ativar <i>Use Taiko skin for Taiko mode</i> nas opções. :contentReference[oaicite:8]{index=8}
        </div>

        <div class="sep"></div>
        <div class="mini"><b>Checklist (exemplos comuns)</b></div>
        <div class="mini">
          • taiko-bar-left / taiko-bar-right / taiko-bar-middle<br/>
          • taiko-drum-inner / taiko-drum-outer<br/>
          • taiko-hitcircle / taiko-hitcircleoverlay<br/>
          • taiko-slider / taiko-slider-fail<br/>
          • taiko-flower / taiko-flower-group<br/>
          • taiko-scorebar-bg / taiko-scorebar-colour<br/>
        </div>

        <div class="sep"></div>
        <div class="mini">
          Se você quiser, eu também posso te gerar uma aba “biblioteca de assets” (com nomes e pastas) pro teu fluxo de skinning.
        </div>
      </div>
    </div>
  `;
}

/* ----- mania UI ----- */
function renderMania(){
  const q = (state.maniaShared.search || "").trim().toLowerCase();
  const keysList = ALL_MANIA_KEYS.filter(k => !q || String(k).includes(q) || (`${k}k`).includes(q));

  const toggles = keysList.map(k=>{
    const on = !!state.maniaShared.enabled[k];
    return `
      <span class="kmPill ${on?"on":""}">
        <span>${k}K</span>
        <label class="switch" title="Incluir ${k}K no export">
          <input type="checkbox" class="kmToggle" data-k="${k}" ${on?"checked":""}>
          <span class="sw"></span>
        </label>
      </span>
    `;
  }).join("");

  const blocks = ALL_MANIA_KEYS
    .filter(k => state.maniaShared.enabled[k])
    .map(k => renderManiaBlock(k))
    .join("");

  return `
    <div class="block open">
      <button class="blockHead" type="button"><span>Mania • keymodes</span><span class="caret">▸</span></button>
      <div class="blockBody">
        <div class="kmTools">
          <input type="text" id="kmSearch" placeholder="Buscar (ex: 4, 7, 12)..." value="${escapeHtml(state.maniaShared.search)}" style="max-width:260px">
          <button class="btn" type="button" id="kmAll">All</button>
          <button class="btn" type="button" id="kmNone">None</button>
          <button class="btn" type="button" id="kmInvert">Invert</button>
          <button class="btn" type="button" id="kmCommon" title="4K + 7K">Common</button>
        </div>

        <div class="kmWrap">${toggles}</div>
        <div class="sep"></div>

        <div class="mini">
          Mania é a parte mais “insana” do skin.ini — e a lista completa aparece no Blank oficial. :contentReference[oaicite:9]{index=9}
        </div>

        <div id="maniaBlocks">${blocks || `<div class="mini">Nenhum modo ativo (pelo menos 1 precisa ficar ligado).</div>`}</div>
      </div>
    </div>
  `;
}

function renderManiaBlock(keys){
  const mode = state.mania[keys] || defaultManiaMode(keys);
  const open = !!state.maniaShared.open[keys];

  // cria inputs Colour0..Colour{keys-1}
  const colourCols = Array.from({length: keys}, (_,i)=>{
    const path = `mania.${keys}.Colour.${i}`;
    return `
      <div class="row">
        <label>Colour${i}</label>
        <div class="inline">
          <input type="color" id="${pathToId(path)}_pick" data-pick-for="${pathToId(path)}">
          <input type="text" id="${pathToId(path)}" data-path="${path}" placeholder="255,255,255">
        </div>
      </div>
    `;
  }).join("");

  const colourLights = Array.from({length: keys}, (_,i)=>{
    const path = `mania.${keys}.ColourLight.${i}`;
    return `
      <div class="row">
        <label>ColourLight${i}</label>
        <div class="inline">
          <input type="color" id="${pathToId(path)}_pick" data-pick-for="${pathToId(path)}">
          <input type="text" id="${pathToId(path)}" data-path="${path}" placeholder="(opcional)">
        </div>
      </div>
    `;
  }).join("");

  return `
    <div class="block ${open?"open":""}" data-keys="${keys}">
      <button class="blockHead" type="button" data-fold="${keys}">
        <span>${keys}K</span>
        <span class="caret">▸</span>
      </button>

      <div class="blockBody">
        <div class="mini"><b>[Mania]</b> • Keys: ${keys}</div>
        <div class="sep"></div>

        <div class="mini"><b>Layout</b></div>
        ${uiRowNum("ColumnStart", `mania.${keys}.ColumnStart`, "(auto/manual)")}
        ${uiRowNum("ColumnRight", `mania.${keys}.ColumnRight`, "(opcional)")}
        ${uiRowText("ColumnSpacing", `mania.${keys}.ColumnSpacing`, "0,0,0...")}
        ${uiRowText("ColumnWidth", `mania.${keys}.ColumnWidth`, "70,70,70...")}
        ${uiRowText("ColumnLineWidth", `mania.${keys}.ColumnLineWidth`, "0,0,0...")}

        <div class="sep"></div>
        <div class="mini"><b>Positions</b></div>
        ${uiRowNum("HitPosition", `mania.${keys}.HitPosition`, "")}
        ${uiRowNum("LightPosition", `mania.${keys}.LightPosition`, "")}
        ${uiRowNum("ScorePosition", `mania.${keys}.ScorePosition`, "")}
        ${uiRowNum("ComboPosition", `mania.${keys}.ComboPosition`, "")}

        <div class="sep"></div>
        <div class="mini"><b>Gameplay toggles</b></div>
        ${uiRowBool("JudgementLine", `mania.${keys}.JudgementLine`)}
        ${uiRowBool("KeysUnderNotes", `mania.${keys}.KeysUnderNotes`)}
        ${uiRowBool("UpsideDown", `mania.${keys}.UpsideDown`)}

        ${uiRowText("KeyFlipWhenUpsideDown", `mania.${keys}.KeyFlipWhenUpsideDown`, "0/1 (ou por coluna)")}
        ${uiRowText("NoteFlipWhenUpsideDown", `mania.${keys}.NoteFlipWhenUpsideDown`, "0/1 (ou por coluna)")}
        ${uiRowText("NoteBodyStyle", `mania.${keys}.NoteBodyStyle`, "stretch / cascadeTop / cascadeBottom")}

        <div class="sep"></div>
        <div class="mini"><b>Stage / Lighting</b></div>
        <div class="grid2">
          <div>
            ${uiRowText("StageLeft", `mania.${keys}.StageLeft`, "")}
            ${uiRowText("StageRight", `mania.${keys}.StageRight`, "")}
            ${uiRowText("StageBottom", `mania.${keys}.StageBottom`, "")}
            ${uiRowText("StageHint", `mania.${keys}.StageHint`, "")}
            ${uiRowText("StageLight", `mania.${keys}.StageLight`, "")}
          </div>
          <div>
            ${uiRowNum("LightingNWidth", `mania.${keys}.LightingNWidth`, "")}
            ${uiRowNum("LightingLWidth", `mania.${keys}.LightingLWidth`, "")}
            ${uiRowText("LightingN", `mania.${keys}.LightingN`, "")}
            ${uiRowText("LightingL", `mania.${keys}.LightingL`, "")}
          </div>
        </div>

        ${uiRowNum("BarlineHeight", `mania.${keys}.BarlineHeight`, "")}
        ${uiRowNum("WidthForNoteHeightScale", `mania.${keys}.WidthForNoteHeightScale`, "")}
        ${uiRowNum("LightFramePerSecond", `mania.${keys}.LightFramePerSecond`, "")}

        ${uiRowText("SpecialStyle", `mania.${keys}.SpecialStyle`, "")}
        ${uiRowText("ComboBurstStyle", `mania.${keys}.ComboBurstStyle`, "")}
        ${uiRowText("SplitStages", `mania.${keys}.SplitStages`, "")}
        ${uiRowText("StageSeparation", `mania.${keys}.StageSeparation`, "")}
        ${uiRowText("SeparateScore", `mania.${keys}.SeparateScore`, "")}

        <div class="sep"></div>
        <div class="mini"><b>Colours (por coluna)</b></div>
        <div class="grid2">
          <div>${colourCols}</div>
          <div>${colourLights}</div>
        </div>

        <div class="sep"></div>
        <div class="mini"><b>Colours (extras)</b></div>
        ${uiRowColor("ColourColumnLine", `mania.${keys}.ColourColumnLine`)}
        ${uiRowColor("ColourBarline", `mania.${keys}.ColourBarline`)}
        ${uiRowColor("ColourJudgementLine", `mania.${keys}.ColourJudgementLine`)}
        ${uiRowColor("ColourKeyWarning", `mania.${keys}.ColourKeyWarning`)}
        ${uiRowColor("ColourHold", `mania.${keys}.ColourHold`)}
        ${uiRowColor("ColourBreak", `mania.${keys}.ColourBreak`)}

        <div class="sep"></div>
        <div class="mini"><b>Patterns de imagem</b> (usa {n} = 1..Keys)</div>
        ${uiRowText("KeyImage# pattern", `mania.${keys}.KeyImage`, "key{n}")}
        ${uiRowText("KeyImage#D pattern", `mania.${keys}.KeyImageD`, "key{n}D")}
        ${uiRowText("NoteImage# pattern", `mania.${keys}.NoteImage`, "note{n}")}
        ${uiRowText("NoteImage#H pattern", `mania.${keys}.NoteImageH`, "note{n}H")}
        ${uiRowText("NoteImage#L pattern", `mania.${keys}.NoteImageL`, "note{n}L")}
        ${uiRowText("NoteImage#T pattern", `mania.${keys}.NoteImageT`, "note{n}T")}
        ${uiRowText("WarningArrow", `mania.${keys}.WarningArrow`, "")}

        <div class="sep"></div>
        <div class="mini"><b>Hit sprites</b></div>
        <div class="grid2">
          ${uiRowText("Hit0", `mania.${keys}.Hit0`)}
          ${uiRowText("Hit50", `mania.${keys}.Hit50`)}
          ${uiRowText("Hit100", `mania.${keys}.Hit100`)}
          ${uiRowText("Hit200", `mania.${keys}.Hit200`)}
          ${uiRowText("Hit300", `mania.${keys}.Hit300`)}
          ${uiRowText("Hit300g", `mania.${keys}.Hit300g`)}
        </div>
      </div>
    </div>
  `;
}

/* ---------- wiring ---------- */
function wireAccordions(root){
  root.querySelectorAll(".blockHead").forEach(head=>{
    const parent = head.closest(".block");
    if(!parent) return;

    // mania fold
    if(head.dataset.fold){
      head.addEventListener("click", ()=>{
        const k = Number(head.dataset.fold);
        const block = root.querySelector(`.block[data-keys="${k}"]`);
        if(!block) return;
        const nowOpen = !block.classList.contains("open");
        block.classList.toggle("open", nowOpen);
        state.maniaShared.open[k] = nowOpen;
        saveSoon();
      });
      return;
    }

    // generic accordion
    head.addEventListener("click", ()=>{
      const nowOpen = !parent.classList.contains("open");
      parent.classList.toggle("open", nowOpen);
    });
  });
}

function bindColorPickers(root){
  root.querySelectorAll("[data-pick-for]").forEach(pick=>{
    const txtId = pick.getAttribute("data-pick-for");
    const txt = document.getElementById(txtId);
    if(!txt) return;

    const hx = rgbToHex(txt.value);
    if(hx) pick.value = hx;

    pick.addEventListener("input", ()=>{
      txt.value = hexToRgb(pick.value);
      onAnyChange();
    });
    txt.addEventListener("input", ()=>{
      const hx2 = rgbToHex(txt.value);
      if(hx2) pick.value = hx2;
    });
  });
}

function hydrateInputsFromState(root){
  // inputs text/number
  root.querySelectorAll("[data-path]").forEach(inp=>{
    const path = inp.getAttribute("data-path");
    const v = getByPath(state, path);

    if(inp.type === "checkbox"){
      inp.checked = !!v;
    }else{
      inp.value = (v ?? "");
    }
  });

  bindColorPickers(root);
  wireAccordions(root);
}

function wirePanelListeners(root){
  // generic input -> state
  root.querySelectorAll("[data-path]").forEach(inp=>{
    const path = inp.getAttribute("data-path");
    const handler = ()=>{
      if(inp.type === "checkbox"){
        setByPath(state, path, !!inp.checked);
      }else{
        setByPath(state, path, inp.value);
      }
      onAnyChange();
    };
    inp.addEventListener("input", handler);
    inp.addEventListener("change", handler);
  });

  // mania tools
  const kmSearch = root.querySelector("#kmSearch");
  if(kmSearch){
    kmSearch.addEventListener("input", ()=>{
      state.maniaShared.search = kmSearch.value || "";
      saveSoon();
      renderActiveTab();
    });
  }

  const btnAll = root.querySelector("#kmAll");
  const btnNone = root.querySelector("#kmNone");
  const btnInv = root.querySelector("#kmInvert");
  const btnCom = root.querySelector("#kmCommon");

  if(btnAll) btnAll.addEventListener("click", ()=>{
    for(const k of ALL_MANIA_KEYS){ state.maniaShared.enabled[k] = true; state.maniaShared.open[k]=false; }
    state.maniaShared.open[4]=true; state.maniaShared.open[7]=true;
    onAnyChange(true);
  });
  if(btnNone) btnNone.addEventListener("click", ()=>{
    for(const k of ALL_MANIA_KEYS){ state.maniaShared.enabled[k] = false; state.maniaShared.open[k]=false; }
    state.maniaShared.enabled[4]=true; state.maniaShared.open[4]=true;
    onAnyChange(true);
  });
  if(btnInv) btnInv.addEventListener("click", ()=>{
    for(const k of ALL_MANIA_KEYS){
      state.maniaShared.enabled[k] = !state.maniaShared.enabled[k];
      if(!state.maniaShared.enabled[k]) state.maniaShared.open[k]=false;
    }
    if(!ALL_MANIA_KEYS.some(k=>state.maniaShared.enabled[k])){
      state.maniaShared.enabled[4]=true; state.maniaShared.open[4]=true;
    }
    onAnyChange(true);
  });
  if(btnCom) btnCom.addEventListener("click", ()=>{
    for(const k of ALL_MANIA_KEYS){ state.maniaShared.enabled[k]=false; state.maniaShared.open[k]=false; }
    state.maniaShared.enabled[4]=true; state.maniaShared.enabled[7]=true;
    state.maniaShared.open[4]=true; state.maniaShared.open[7]=true;
    onAnyChange(true);
  });

  root.querySelectorAll(".kmToggle").forEach(t=>{
    t.addEventListener("change", ()=>{
      const k = Number(t.dataset.k);
      const was = !!state.maniaShared.enabled[k];
      const now = !!t.checked;
      state.maniaShared.enabled[k] = now;
      state.maniaShared.open[k] = now ? true : false;

      if(!ALL_MANIA_KEYS.some(x=>state.maniaShared.enabled[x])){
        state.maniaShared.enabled[4]=true;
        state.maniaShared.open[4]=true;
      }
      onAnyChange(true);
    });
  });
}

/* ---------- ini generation ---------- */
function genIni(){
  const out = [];

  // [General]
  out.push("[General]");
  pushKV(out, "Name", state.general.Name);
  pushKV(out, "Author", state.general.Author);
  out.push(fmtKV("Version", state.version));

  const g = state.general;
  pushKV(out, "AnimationFramerate", g.AnimationFramerate);
  pushKV(out, "AllowSliderBallTint", bool01(!!g.AllowSliderBallTint));
  pushKV(out, "ComboBurstRandom", g.ComboBurstRandom);
  pushKV(out, "CursorCentre", bool01(!!g.CursorCentre));
  pushKV(out, "CursorExpand", bool01(!!g.CursorExpand));
  pushKV(out, "CursorRotate", bool01(!!g.CursorRotate));
  pushKV(out, "CursorTrailRotate", bool01(!!g.CursorTrailRotate));
  pushKV(out, "CustomComboBurstSounds", g.CustomComboBurstSounds);
  pushKV(out, "HitCircleOverlayAboveNumber", bool01(!!g.HitCircleOverlayAboveNumber));
  pushKV(out, "LayeredHitSounds", bool01(!!g.LayeredHitSounds));
  pushKV(out, "SliderBallFlip", bool01(!!g.SliderBallFlip));
  pushKV(out, "SpinnerFadePlayfield", bool01(!!g.SpinnerFadePlayfield));
  pushKV(out, "SpinnerFrequencyModulate", g.SpinnerFrequencyModulate);
  pushKV(out, "SpinnerNoBlink", bool01(!!g.SpinnerNoBlink));

  out.push("");

  // [Colours]
  const c = state.colours;
  const colourKeys = [
    "Combo1","Combo2","Combo3","Combo4","Combo5","Combo6","Combo7","Combo8",
    "InputOverlayText","MenuGlow","SliderBall","SliderBorder","SliderTrackOverride",
    "SongSelectActiveText","SongSelectInactiveText","SpinnerBackground","StarBreakAdditive"
  ];
  const hasColours = colourKeys.some(k => !isBlank(c[k]));
  if(hasColours){
    out.push("[Colours]");
    for(const k of colourKeys) pushKV(out, k, c[k]);
    out.push("");
  }

  // [Fonts]
  const f = state.fonts;
  const fontKeys = ["HitCirclePrefix","HitCircleOverlap","ScorePrefix","ScoreOverlap","ComboPrefix","ComboOverlap"];
  const hasFonts = fontKeys.some(k => !isBlank(f[k]));
  if(hasFonts){
    out.push("[Fonts]");
    for(const k of fontKeys) pushKV(out, k, f[k]);
    out.push("");
  }

  // [CatchTheBeat]
  const ca = state.catch;
  const catchKeys = ["HyperDash","HyperDashFruit","HyperDashAfterImage"];
  const hasCatch = catchKeys.some(k => !isBlank(ca[k]));
  if(hasCatch){
    out.push("[CatchTheBeat]");
    for(const k of catchKeys) pushKV(out, k, ca[k]);
    out.push("");
  }

  // [Mania]
  for(const keys of ALL_MANIA_KEYS){
    if(!state.maniaShared.enabled[keys]) continue;
    out.push("[Mania]");
    out.push(...genManiaBlock(keys));
    out.push("");
  }

  while(out.length && out[out.length-1]==="") out.pop();
  return out.join("\n");
}

function pat(pattern, n){
  const p = String(pattern||"").trim();
  if(!p) return "";
  return p.replaceAll("{n}", String(n));
}

function genManiaBlock(keys){
  const m = state.mania[keys] || defaultManiaMode(keys);
  const lines = [];

  lines.push(fmtKV("Keys", keys));
  spacer(lines);

  // layout lines: ColumnWidth/Spacing etc são CSV; se usuário botar só "70", replicamos
  const cwRaw = cleanLine(m.ColumnWidth);
  const csRaw = cleanLine(m.ColumnSpacing);

  function normalizeCsv(raw, count, fallback){
    const r = cleanLine(raw);
    if(!r) return fallback;
    if(r.includes(",")) return r;
    return Array.from({length: count}, ()=>r).join(",");
  }
  lines.push(fmtKV("ColumnWidth", normalizeCsv(cwRaw, keys, Array.from({length:keys}, ()=>"70").join(","))));
  lines.push(fmtKV("ColumnSpacing", normalizeCsv(csRaw, Math.max(0,keys-1), Array.from({length:Math.max(0,keys-1)}, ()=>"0").join(","))));
  pushKV(lines, "ColumnStart", m.ColumnStart);
  pushKV(lines, "ColumnRight", m.ColumnRight);
  pushKV(lines, "ColumnLineWidth", normalizeCsv(cleanLine(m.ColumnLineWidth), keys+1, Array.from({length:keys+1}, ()=>"0").join(",")));
  spacer(lines);

  // positions + toggles
  pushKV(lines, "HitPosition", m.HitPosition);
  pushKV(lines, "LightPosition", m.LightPosition);
  pushKV(lines, "ScorePosition", m.ScorePosition);
  pushKV(lines, "ComboPosition", m.ComboPosition);
  spacer(lines);

  lines.push(fmtKV("JudgementLine", bool01(!!m.JudgementLine)));
  lines.push(fmtKV("KeysUnderNotes", bool01(!!m.KeysUnderNotes)));
  lines.push(fmtKV("UpsideDown", bool01(!!m.UpsideDown)));
  spacer(lines);

  pushKV(lines, "KeyFlipWhenUpsideDown", m.KeyFlipWhenUpsideDown);
  pushKV(lines, "NoteFlipWhenUpsideDown", m.NoteFlipWhenUpsideDown);
  pushKV(lines, "NoteBodyStyle", m.NoteBodyStyle);
  spacer(lines);

  // stage/lighting
  header(lines, "stage");
  pushKV(lines, "StageLeft", m.StageLeft);
  pushKV(lines, "StageRight", m.StageRight);
  pushKV(lines, "StageBottom", m.StageBottom);
  pushKV(lines, "StageHint", m.StageHint);
  pushKV(lines, "StageLight", m.StageLight);
  pushKV(lines, "LightingNWidth", m.LightingNWidth);
  pushKV(lines, "LightingLWidth", m.LightingLWidth);
  pushKV(lines, "LightingN", m.LightingN);
  pushKV(lines, "LightingL", m.LightingL);
  spacer(lines);

  pushKV(lines, "BarlineHeight", m.BarlineHeight);
  pushKV(lines, "WidthForNoteHeightScale", m.WidthForNoteHeightScale);
  pushKV(lines, "LightFramePerSecond", m.LightFramePerSecond);
  pushKV(lines, "SpecialStyle", m.SpecialStyle);
  pushKV(lines, "ComboBurstStyle", m.ComboBurstStyle);
  pushKV(lines, "SplitStages", m.SplitStages);
  pushKV(lines, "StageSeparation", m.StageSeparation);
  pushKV(lines, "SeparateScore", m.SeparateScore);
  spacer(lines);

  // colours
  header(lines, "colours");
  for(let i=0;i<keys;i++){
    const v = cleanLine(m.Colour?.[i]);
    if(v) lines.push(fmtKV(`Colour${i}`, v));
  }
  spacer(lines);
  for(let i=0;i<keys;i++){
    const v = cleanLine(m.ColourLight?.[i]);
    if(v) lines.push(fmtKV(`ColourLight${i}`, v));
  }
  pushKV(lines, "ColourColumnLine", m.ColourColumnLine);
  pushKV(lines, "ColourBarline", m.ColourBarline);
  pushKV(lines, "ColourJudgementLine", m.ColourJudgementLine);
  pushKV(lines, "ColourKeyWarning", m.ColourKeyWarning);
  pushKV(lines, "ColourHold", m.ColourHold);
  pushKV(lines, "ColourBreak", m.ColourBreak);
  spacer(lines);

  // patterns -> expand to KeyImage0.., NoteImage0.. etc
  header(lines, "images");
  for(let idx=0; idx<keys; idx++){
    const n = idx+1;
    const a = pat(m.KeyImage, n); if(a) lines.push(fmtKV(`KeyImage${idx}`, a));
  }
  spacer(lines);
  for(let idx=0; idx<keys; idx++){
    const n = idx+1;
    const a = pat(m.KeyImageD, n); if(a) lines.push(fmtKV(`KeyImage${idx}D`, a));
  }
  spacer(lines);

  for(let idx=0; idx<keys; idx++){
    const n = idx+1;
    const a = pat(m.NoteImage, n); if(a) lines.push(fmtKV(`NoteImage${idx}`, a));
  }
  spacer(lines);
  for(let idx=0; idx<keys; idx++){
    const n = idx+1;
    const a = pat(m.NoteImageH, n); if(a) lines.push(fmtKV(`NoteImage${idx}H`, a));
  }
  spacer(lines);
  for(let idx=0; idx<keys; idx++){
    const n = idx+1;
    const a = pat(m.NoteImageL, n); if(a) lines.push(fmtKV(`NoteImage${idx}L`, a));
  }
  spacer(lines);
  for(let idx=0; idx<keys; idx++){
    const n = idx+1;
    const a = pat(m.NoteImageT, n); if(a) lines.push(fmtKV(`NoteImage${idx}T`, a));
  }
  spacer(lines);

  pushKV(lines, "WarningArrow", m.WarningArrow);
  spacer(lines);

  // hits
  header(lines, "hits");
  pushKV(lines, "Hit0", m.Hit0);
  pushKV(lines, "Hit50", m.Hit50);
  pushKV(lines, "Hit100", m.Hit100);
  pushKV(lines, "Hit200", m.Hit200);
  pushKV(lines, "Hit300", m.Hit300);
  pushKV(lines, "Hit300g", m.Hit300g);

  while(lines.length && lines[lines.length-1]==="") lines.pop();
  return lines;
}

/* ---------- import parser ---------- */
function parseIni(text){
  const lines = String(text||"").split("\n");
  let section = "";
  const parsed = {
    General:{}, Colours:{}, Fonts:{}, CatchTheBeat:{},
    Mania: [] // array of {Keys, kv}
  };

  let curMania = null;

  for(const raw of lines){
    const line = raw.trim();
    if(!line || line.startsWith("//")) continue;

    const sec = line.match(/^\[(.+?)\]$/);
    if(sec){
      section = sec[1];
      if(section === "Mania"){
        curMania = { Keys:null, kv:{} };
        parsed.Mania.push(curMania);
      }else{
        curMania = null;
      }
      continue;
    }

    const m = line.match(/^([A-Za-z0-9]+)\s*:\s*(.*)$/);
    if(!m) continue;
    const key = m[1];
    const val = m[2];

    if(section === "General") parsed.General[key]=val;
    else if(section === "Colours") parsed.Colours[key]=val;
    else if(section === "Fonts") parsed.Fonts[key]=val;
    else if(section === "CatchTheBeat") parsed.CatchTheBeat[key]=val;
    else if(section === "Mania" && curMania){
      if(key === "Keys"){
        curMania.Keys = intOr(val, null);
        curMania.kv[key]=val;
      }else{
        curMania.kv[key]=val;
      }
    }
  }
  return parsed;
}

function applyParsed(parsed){
  // version
  if(parsed.General.Version) state.version = parsed.General.Version;

  // General known
  for(const k in state.general){
    if(k in parsed.General){
      if(typeof state.general[k] === "boolean"){
        state.general[k] = parsed.General[k].trim() === "1";
      }else{
        state.general[k] = parsed.General[k];
      }
    }
  }

  // Colours
  for(const k in state.colours){
    if(k in parsed.Colours) state.colours[k] = parsed.Colours[k];
  }

  // Fonts
  for(const k in state.fonts){
    if(k in parsed.Fonts) state.fonts[k] = parsed.Fonts[k];
  }

  // Catch
  for(const k in state.catch){
    if(k in parsed.CatchTheBeat) state.catch[k] = parsed.CatchTheBeat[k];
  }

  // Mania blocks
  for(const blk of parsed.Mania){
    const keys = blk.Keys;
    if(!keys || keys<1 || keys>18) continue;
    state.maniaShared.enabled[keys] = true;

    const m = state.mania[keys] || defaultManiaMode(keys);

    // direct keys we support
    const direct = [
      "ColumnStart","ColumnRight","ColumnSpacing","ColumnWidth","ColumnLineWidth",
      "BarlineHeight","LightingNWidth","LightingLWidth","WidthForNoteHeightScale",
      "HitPosition","LightPosition","ComboPosition","ScorePosition",
      "JudgementLine","LightFramePerSecond","SpecialStyle","ComboBurstStyle","SplitStages",
      "StageSeparation","SeparateScore","KeysUnderNotes","UpsideDown",
      "KeyFlipWhenUpsideDown","NoteFlipWhenUpsideDown","NoteBodyStyle",
      "StageLeft","StageRight","StageBottom","StageHint","StageLight","LightingN","LightingL",
      "WarningArrow",
      "Hit0","Hit50","Hit100","Hit200","Hit300","Hit300g"
    ];
    for(const k of direct){
      if(k in blk.kv){
        if(typeof m[k] === "boolean") m[k] = blk.kv[k].trim() === "1";
        else m[k] = blk.kv[k];
      }
    }

    // Colour / ColourLight per idx
    for(let i=0;i<keys;i++){
      const ck = `Colour${i}`;
      const lk = `ColourLight${i}`;
      if(ck in blk.kv){ m.Colour[i] = blk.kv[ck]; }
      if(lk in blk.kv){ m.ColourLight[i] = blk.kv[lk]; }
    }

    // patterns: tenta inferir “pattern” a partir do idx0 e idx1 se houver
    // (bem heurístico, mas ajuda em import real)
    function guessPattern(prefix){
      const a = blk.kv[`${prefix}0`];
      const b = blk.kv[`${prefix}1`];
      if(!a || !b) return "";
      // se diferem só em "1"/"2", converte pra {n}
      const a2 = a.replaceAll("1","{n}");
      const b2 = b.replaceAll("2","{n}");
      if(a2 === b2) return a2;
      return "";
    }
    const gKey = guessPattern("KeyImage");
    const gKeyD = guessPattern("KeyImage") && guessPattern("KeyImageD");
    const gNote = guessPattern("NoteImage");
    const gNoteH = guessPattern("NoteImageH");
    const gNoteL = guessPattern("NoteImageL");
    const gNoteT = guessPattern("NoteImageT");

    if(gKey) m.KeyImage = gKey;
    if(gKeyD) m.KeyImageD = gKeyD;
    if(gNote) m.NoteImage = gNote;
    if(gNoteH) m.NoteImageH = gNoteH;
    if(gNoteL) m.NoteImageL = gNoteL;
    if(gNoteT) m.NoteImageT = gNoteT;

    state.mania[keys] = m;
  }

  saveSoon(true);
  renderActiveTab();
}

/* ---------- save/load ---------- */
function saveState(){
  try{
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    $("savePulse").textContent = "Saved";
    setTimeout(()=>{ $("savePulse").textContent="—"; }, 700);
  }catch(e){
    $("savePulse").textContent = "ERR";
  }
}

function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return;
    const s = JSON.parse(raw);
    if(!s) return;

    // shallow merge de segurança
    state.pretty = !!s.pretty;
    state.commentEmpty = !!s.commentEmpty;
    state.version = s.version ?? "latest";
    state.activeTab = s.activeTab ?? "general";

    Object.assign(state.general, s.general || {});
    Object.assign(state.colours, s.colours || {});
    Object.assign(state.fonts, s.fonts || {});
    Object.assign(state.catch, s.catch || {});

    if(s.maniaShared){
      state.maniaShared.search = s.maniaShared.search ?? "";
      for(const k of ALL_MANIA_KEYS){
        state.maniaShared.enabled[k] = !!s.maniaShared.enabled?.[k];
        state.maniaShared.open[k] = !!s.maniaShared.open?.[k];
      }
      if(!ALL_MANIA_KEYS.some(k=>state.maniaShared.enabled[k])){
        state.maniaShared.enabled[4]=true; state.maniaShared.open[4]=true;
      }
    }

    if(s.mania){
      for(const k of ALL_MANIA_KEYS){
        if(s.mania[k]) state.mania[k] = { ...defaultManiaMode(k), ...s.mania[k] };
      }
    }
  }catch(e){}
}

const saveSoon = debounce((force=false)=>{
  saveState();
  if(force) updatePreview();
}, 350);

const previewSoon = debounce(()=>{
  updatePreview();
}, 90);

function onAnyChange(rerender=false){
  if(rerender) renderActiveTab();
  previewSoon();
  saveSoon();
}

/* ---------- preview & actions ---------- */
function updatePreview(){
  $("preview").value = genIni();
}

function downloadIni(){
  const text = $("preview").value || genIni();
  const blob = new Blob([text], {type:"text/plain;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "skin.ini";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

async function copyIni(){
  try{
    await navigator.clipboard.writeText($("preview").value || genIni());
    $("statusBadge").textContent = "copiado!";
    setTimeout(()=>$("statusBadge").textContent="ok", 900);
  }catch(e){
    $("statusBadge").textContent = "falhou";
    setTimeout(()=>$("statusBadge").textContent="ok", 900);
  }
}

function wipeAll(){
  if(!confirm("Reset total + apagar autosave?")) return;
  try{ localStorage.removeItem(STORAGE_KEY); }catch(e){}
  location.reload();
}

/* ---------- top-level wiring ---------- */
$("downloadIni").addEventListener("click", downloadIni);
$("copyIni").addEventListener("click", copyIni);
$("wipeAll").addEventListener("click", wipeAll);
$("refresh").addEventListener("click", updatePreview);

$("pretty").addEventListener("change", ()=>{
  state.pretty = $("pretty").checked;
  onAnyChange(true);
});
$("commentEmpty").addEventListener("change", ()=>{
  state.commentEmpty = $("commentEmpty").checked;
  onAnyChange(true);
});
$("versionPick").addEventListener("change", ()=>{
  state.version = $("versionPick").value;
  onAnyChange();
});

/* import modal */
$("importOpen").addEventListener("click", ()=>{
  $("importArea").value = $("preview").value || "";
  $("importDlg").showModal();
});
$("importApply").addEventListener("click", ()=>{
  const parsed = parseIni($("importArea").value || "");
  applyParsed(parsed);
  $("importDlg").close();
});

/* ---------- music (WebAudio ambient) ---------- */
let audio = {
  ctx:null,
  master:null,
  playing:false,
  nodes:[]
};

function buildAmbient(){
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const master = ctx.createGain();
  master.gain.value = Number($("musicVol").value || 0.18);
  master.connect(ctx.destination);

  // “pad” com 3 osciladores + filtro
  const filter = ctx.createBiquadFilter();
  filter.type = "lowpass";
  filter.frequency.value = 800;
  filter.Q.value = 0.7;
  filter.connect(master);

  const base = 110; // A2
  const detunes = [-7, 0, +7]; // cents
  const osc = detunes.map((d,i)=>{
    const o = ctx.createOscillator();
    const g = ctx.createGain();

    o.type = i===1 ? "sine" : "triangle";
    o.frequency.value = base * (i===0 ? 1 : (i===1 ? 1.5 : 2.0));
    o.detune.value = d;

    g.gain.value = 0.0;
    o.connect(g);
    g.connect(filter);
    o.start();

    return {o,g};
  });

  // LFO suave pra respirar
  const lfo = ctx.createOscillator();
  lfo.type = "sine";
  lfo.frequency.value = 0.05;
  const lfoGain = ctx.createGain();
  lfoGain.gain.value = 0.06;
  lfo.connect(lfoGain);
  lfoGain.connect(master.gain);
  lfo.start();

  // fade-in
  const now = ctx.currentTime;
  for(const n of osc){
    n.g.gain.cancelScheduledValues(now);
    n.g.gain.setValueAtTime(0.0001, now);
    n.g.gain.linearRampToValueAtTime(0.12, now + 1.2);
  }

  audio.ctx = ctx;
  audio.master = master;
  audio.nodes = [...osc, {lfo,lfoGain,filter}];
}

async function toggleMusic(){
  try{
    if(!audio.ctx){
      buildAmbient();
      audio.playing = true;
      $("musicToggle").textContent = "⏸ ambient";
      return;
    }
    if(audio.ctx.state === "suspended"){
      await audio.ctx.resume();
      audio.playing = true;
      $("musicToggle").textContent = "⏸ ambient";
      return;
    }
    if(audio.ctx.state === "running"){
      await audio.ctx.suspend();
      audio.playing = false;
      $("musicToggle").textContent = "▶ ambient";
      return;
    }
  }catch(e){}
}

$("musicToggle").addEventListener("click", toggleMusic);
$("musicVol").addEventListener("input", ()=>{
  if(audio.master) audio.master.gain.value = Number($("musicVol").value || 0.18);
});

/* ---------- init ---------- */
loadState();
$("pretty").checked = state.pretty;
$("commentEmpty").checked = state.commentEmpty;
$("versionPick").value = state.version;

renderTabs();
renderActiveTab();
updatePreview();
</script>
</body>
</html>
