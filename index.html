<script>
/* ===========================
   skin.ini studio — refactor v1
   - cursor options in [General]
   - less duplicated listeners via delegation
   - cleaner state + render flow
=========================== */

const $ = (id) => document.getElementById(id);

const STORAGE_KEY = "skinini_studio_v8_mania_only_refactor";
const ALL_MANIA_KEYS = Array.from({ length: 18 }, (_, i) => i + 1);

/* ---------- utils ---------- */
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const cleanLine = (s) => String(s ?? "").replace(/\r/g, "").trimEnd();
const isBlank = (v) => cleanLine(v) === "";
const bool01 = (b) => (b ? "1" : "0");

function debounce(fn, wait) {
  let t = null;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), wait);
  };
}

function rgbToHex(rgb) {
  const m = String(rgb || "").match(/^\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*$/);
  if (!m) return null;
  const r = clamp(parseInt(m[1], 10), 0, 255);
  const g = clamp(parseInt(m[2], 10), 0, 255);
  const b = clamp(parseInt(m[3], 10), 0, 255);
  return "#" + [r, g, b].map((x) => x.toString(16).padStart(2, "0")).join("");
}

function hexToRgb(hex) {
  const h = String(hex || "").replace("#", "").trim();
  if (!/^[0-9a-fA-F]{6}$/.test(h)) return "";
  const r = parseInt(h.slice(0, 2), 16);
  const g = parseInt(h.slice(2, 4), 16);
  const b = parseInt(h.slice(4, 6), 16);
  return `${r},${g},${b}`;
}

function escapeHtml(s) {
  return String(s ?? "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#39;");
}

/* ---------- path helpers ---------- */
function pathToId(path) {
  return "p_" + path.replaceAll(".", "__").replaceAll("[", "_").replaceAll("]", "_");
}

function getByPath(obj, path) {
  const parts = path.split(".");
  let cur = obj;
  for (const p of parts) {
    if (cur == null) return undefined;
    cur = cur[p];
  }
  return cur;
}

function setByPath(obj, path, value) {
  const parts = path.split(".");
  let cur = obj;
  for (let i = 0; i < parts.length - 1; i++) {
    const p = parts[i];
    if (!(p in cur)) cur[p] = {};
    cur = cur[p];
  }
  cur[parts[parts.length - 1]] = value;
}

/* ---------- ini formatting ---------- */
function fmtKV(key, value) {
  const v = cleanLine(value);
  if (state.pretty) {
    const k = String(key).padEnd(32, " ");
    return `${k} : ${v}`;
  }
  return `${key}: ${v}`;
}

function pushKV(lines, key, value) {
  const v = cleanLine(value);
  if (v !== "") {
    lines.push(fmtKV(key, v));
    return;
  }
  if (state.commentEmpty) {
    if (state.pretty) {
      const k = String(key).padEnd(32, " ");
      lines.push(`// ${k} :`);
    } else {
      lines.push(`//${key}:`);
    }
  }
}

function spacer(lines) {
  if (state.pretty) lines.push("");
}

function header(lines, title) {
  if (state.pretty) {
    lines.push(`// ${title} --`);
    lines.push("");
  }
}

function pat(pattern, n) {
  const p = String(pattern || "").trim();
  if (!p) return "";
  return p.replaceAll("{n}", String(n));
}

/* ---------- default state ---------- */
function defaultManiaMode() {
  return {
    ColumnStart: "",
    ColumnRight: "",
    ColumnSpacing: "0",
    ColumnWidth: "70",
    ColumnLineWidth: "",

    HitPosition: "",
    LightPosition: "",
    ScorePosition: "",
    ComboPosition: "",

    JudgementLine: true,
    KeysUnderNotes: false,
    UpsideDown: false,

    BarlineHeight: "",
    WidthForNoteHeightScale: "",

    ColourColumnLine: "",
    ColourBarline: "",
    ColourJudgementLine: "",
    ColourKeyWarning: "",
    ColourHold: "",
    ColourBreak: "",
    Colour: {},
    ColourLight: {},

    AutoColumnStart: true,

    // patterns (use {n})
    pKey: "",
    pKeyD: "",
    pNote: "",
    pNoteH: "",
    pNoteL: "",
    pNoteT: "",
    WarningArrow: "",
  };
}

function makeDefaultState() {
  return {
    activeTab: "mania",
    exportMania: true,

    pretty: true,        // "h style"
    commentEmpty: false,

    version: "latest",

    general: {
      Name: "",
      Author: "",

      // cursor (skin.ini [General])
      CursorRotate: false,
      CursorTrailRotate: false,
      CursorExpand: true,
      CursorCentre: true,
    },

    maniaShared: {
      enabled: Object.fromEntries(ALL_MANIA_KEYS.map((k) => [k, k === 4])),
      open: Object.fromEntries(ALL_MANIA_KEYS.map((k) => [k, k === 4])),
    },

    mania: Object.fromEntries(ALL_MANIA_KEYS.map((k) => [k, defaultManiaMode()])),
  };
}

let state = makeDefaultState();

/* ---------- tabs ---------- */
const TABS = [
  { key: "mania", title: "Mania", render: renderMania },
  { key: "preview", title: "Preview", render: renderPreviewOnly },
];

/* ---------- UI row builders ---------- */
function uiRowText(label, path, placeholder = "") {
  const id = pathToId(path);
  return `
    <div class="row">
      <label for="${id}">${label}</label>
      <input type="text" id="${id}" data-path="${path}" placeholder="${escapeHtml(placeholder)}">
    </div>
  `;
}

function uiRowNum(label, path, placeholder = "") {
  const id = pathToId(path);
  return `
    <div class="row">
      <label for="${id}">${label}</label>
      <input type="number" id="${id}" data-path="${path}" placeholder="${escapeHtml(placeholder)}">
    </div>
  `;
}

function uiRowBool(label, path) {
  const id = pathToId(path);
  return `
    <div class="row">
      <label>${label}</label>
      <div class="inline">
        <label class="switch">
          <input type="checkbox" id="${id}" data-path="${path}">
          <span class="sw"></span>
        </label>
      </div>
    </div>
  `;
}

function uiRowColor(label, path) {
  const id = pathToId(path);
  const pickId = id + "_pick";
  return `
    <div class="row">
      <label>${label}</label>
      <div class="inline">
        <input type="color" id="${pickId}" data-pick-for="${id}">
        <input type="text" id="${id}" data-path="${path}" placeholder="255,255,255">
      </div>
    </div>
  `;
}

/* ---------- rendering ---------- */
function setActiveTab(k) {
  state.activeTab = k;
  renderDockActive();
  renderActiveTab();
  saveSoon();
}

function renderDockActive() {
  document.querySelectorAll(".icoBtn[data-tab]").forEach((b) => {
    b.classList.toggle("active", b.dataset.tab === state.activeTab);
  });
}

function updateTopSub() {
  const t = TABS.find((x) => x.key === state.activeTab)?.title ?? "—";
  $("topSub").textContent = t;
  $("panelTitle").textContent = t;
}

function renderActiveTab() {
  updateTopSub();
  const tab = TABS.find((t) => t.key === state.activeTab) || TABS[0];
  $("panel").innerHTML = tab.render();

  hydrateInputsFromState($("panel"));
  updateModeBadge();
  onAnyChange(true); // refresh preview without spamming saves
}

function renderMania() {
  const pills = ALL_MANIA_KEYS.map((k) => {
    const on = !!state.maniaShared.enabled[k];
    return `
      <span class="kmPill ${on ? "on" : ""}">
        <span>${k}K</span>
        <label class="switch">
          <input type="checkbox" class="kmToggle" data-k="${k}" ${on ? "checked" : ""}>
          <span class="sw"></span>
        </label>
      </span>
    `;
  }).join("");

  const blocks = ALL_MANIA_KEYS
    .filter((k) => state.maniaShared.enabled[k])
    .map((k) => renderManiaBlock(k))
    .join("");

  return `
    <div class="block open">
      <button class="blockHead" type="button"><span>[General] meta</span><span class="caret">▸</span></button>
      <div class="blockBody">
        ${uiRowText("Name", "general.Name")}
        ${uiRowText("Author", "general.Author")}

        <div class="row">
          <label>Version</label>
          <input type="text" value="${escapeHtml(state.version)}" readonly>
        </div>

        <div class="block open" style="margin-top:10px;">
          <button class="blockHead" type="button"><span>cursor</span><span class="caret">▸</span></button>
          <div class="blockBody">
            ${uiRowBool("CursorCentre", "general.CursorCentre")}
            ${uiRowBool("CursorExpand", "general.CursorExpand")}
            ${uiRowBool("CursorRotate", "general.CursorRotate")}
            ${uiRowBool("CursorTrailRotate", "general.CursorTrailRotate")}
          </div>
        </div>
      </div>
    </div>

    ${!state.exportMania ? `<div class="disabledHint">Mania export is disabled</div>` : ``}

    <div class="block open">
      <button class="blockHead" type="button"><span>keymodes</span><span class="caret">▸</span></button>
      <div class="blockBody">
        <div class="kmRow">${pills}</div>
      </div>
    </div>

    <div id="maniaBlocks">
      ${blocks || `<div class="disabledHint">no active mode</div>`}
    </div>
  `;
}

function renderManiaBlock(keys) {
  const open = !!state.maniaShared.open[keys];

  const colourCols = Array.from({ length: keys }, (_, i) => {
    const uiIndex = i + 1;
    const path = `mania.${keys}.Colour.${uiIndex}`;
    return `
      <div class="row">
        <label>Colour${uiIndex}</label>
        <div class="inline">
          <input type="color" id="${pathToId(path)}_pick" data-pick-for="${pathToId(path)}">
          <input type="text" id="${pathToId(path)}" data-path="${path}" placeholder="255,255,255">
        </div>
      </div>
    `;
  }).join("");

  const colourLights = Array.from({ length: keys }, (_, i) => {
    const uiIndex = i + 1;
    const path = `mania.${keys}.ColourLight.${uiIndex}`;
    return `
      <div class="row">
        <label>ColourLight${uiIndex}</label>
        <div class="inline">
          <input type="color" id="${pathToId(path)}_pick" data-pick-for="${pathToId(path)}">
          <input type="text" id="${pathToId(path)}" data-path="${path}" placeholder="">
        </div>
      </div>
    `;
  }).join("");

  return `
    <div class="block ${open ? "open" : ""}" data-keys="${keys}">
      <button class="blockHead" type="button" data-fold="${keys}">
        <span>${keys}K</span>
        <span class="caret">▸</span>
      </button>

      <div class="blockBody">
        <div class="block open">
          <button class="blockHead" type="button"><span>layout</span><span class="caret">▸</span></button>
          <div class="blockBody">
            ${uiRowBool("Auto ColumnStart", `mania.${keys}.AutoColumnStart`)}
            ${uiRowNum("ColumnStart", `mania.${keys}.ColumnStart`)}
            ${uiRowNum("ColumnRight", `mania.${keys}.ColumnRight`)}
            ${uiRowText("ColumnWidth", `mania.${keys}.ColumnWidth`, "70 or 70,70,70")}
            ${uiRowText("ColumnSpacing", `mania.${keys}.ColumnSpacing`, "0 or 0,0,0")}
            ${uiRowText("ColumnLineWidth", `mania.${keys}.ColumnLineWidth`, "")}
          </div>
        </div>

        <div class="block open">
          <button class="blockHead" type="button"><span>positions</span><span class="caret">▸</span></button>
          <div class="blockBody">
            ${uiRowNum("HitPosition", `mania.${keys}.HitPosition`)}
            ${uiRowNum("LightPosition", `mania.${keys}.LightPosition`)}
            ${uiRowNum("ScorePosition", `mania.${keys}.ScorePosition`)}
            ${uiRowNum("ComboPosition", `mania.${keys}.ComboPosition`)}
          </div>
        </div>

        <div class="block">
          <button class="blockHead" type="button"><span>toggles</span><span class="caret">▸</span></button>
          <div class="blockBody">
            ${uiRowBool("JudgementLine", `mania.${keys}.JudgementLine`)}
            ${uiRowBool("KeysUnderNotes", `mania.${keys}.KeysUnderNotes`)}
            ${uiRowBool("UpsideDown", `mania.${keys}.UpsideDown`)}
          </div>
        </div>

        <div class="block open">
          <button class="blockHead" type="button"><span>colours</span><span class="caret">▸</span></button>
          <div class="blockBody">
            <div class="grid2">
              <div>${colourCols}</div>
              <div>${colourLights}</div>
            </div>

            ${uiRowColor("ColourColumnLine", `mania.${keys}.ColourColumnLine`)}
            ${uiRowColor("ColourBarline", `mania.${keys}.ColourBarline`)}
            ${uiRowColor("ColourJudgementLine", `mania.${keys}.ColourJudgementLine`)}
            ${uiRowColor("ColourKeyWarning", `mania.${keys}.ColourKeyWarning`)}
            ${uiRowColor("ColourHold", `mania.${keys}.ColourHold`)}
            ${uiRowColor("ColourBreak", `mania.${keys}.ColourBreak`)}
          </div>
        </div>

        <div class="block open">
          <button class="blockHead" type="button"><span>paths</span><span class="caret">▸</span></button>
          <div class="blockBody">
            ${uiRowText("KeyImage# pattern", `mania.${keys}.pKey`, "e.g. mania/key{n}")}
            ${uiRowText("KeyImage#D pattern", `mania.${keys}.pKeyD`, "e.g. mania/key{n}d")}
            ${uiRowText("NoteImage# pattern", `mania.${keys}.pNote`, "e.g. mania/note{n}")}
            ${uiRowText("NoteImage#H pattern", `mania.${keys}.pNoteH`, "e.g. mania/note{n}h")}
            ${uiRowText("NoteImage#L pattern", `mania.${keys}.pNoteL`, "e.g. mania/note{n}l")}
            ${uiRowText("NoteImage#T pattern", `mania.${keys}.pNoteT`, "e.g. mania/note{n}t")}
            ${uiRowText("WarningArrow", `mania.${keys}.WarningArrow`, "e.g. mania/warning")}
          </div>
        </div>
      </div>
    </div>
  `;
}

function renderPreviewOnly() {
  return `<div class="disabledHint">use the right panel</div>`;
}

/* ---------- hydration + interactions ---------- */
function hydrateInputsFromState(root) {
  // set values
  root.querySelectorAll("[data-path]").forEach((inp) => {
    const path = inp.getAttribute("data-path");
    const v = getByPath(state, path);
    if (inp.type === "checkbox") inp.checked = !!v;
    else inp.value = (v ?? "");
  });

  // handle AutoColumnStart -> disable ColumnStart
  root.querySelectorAll('[data-path$=".AutoColumnStart"]').forEach((chk) => {
    const path = chk.getAttribute("data-path");
    const colPath = path.replace(".AutoColumnStart", ".ColumnStart");
    const col = root.querySelector(`[data-path="${colPath}"]`);
    if (!col) return;

    col.disabled = !!chk.checked;
    col.placeholder = chk.checked ? "auto" : "";
    if (chk.checked) col.value = "";
  });

  // sync color pickers
  root.querySelectorAll('input[type="color"][data-pick-for]').forEach((pick) => {
    const txtId = pick.getAttribute("data-pick-for");
    const txt = root.querySelector(`#${CSS.escape(txtId)}`);
    if (!txt) return;
    const hx = rgbToHex(txt.value);
    if (hx) pick.value = hx;
  });
}

function handleAccordionClick(root, head) {
  const parent = head.closest(".block");
  if (!parent) return;

  // special: fold mania key blocks (persist open state)
  if (head.dataset.fold) {
    const k = Number(head.dataset.fold);
    const block = root.querySelector(`.block[data-keys="${k}"]`);
    if (!block) return;
    const nowOpen = !block.classList.contains("open");
    block.classList.toggle("open", nowOpen);
    state.maniaShared.open[k] = nowOpen;
    saveSoon();
    return;
  }

  const nowOpen = !parent.classList.contains("open");
  parent.classList.toggle("open", nowOpen);
}

function syncColumnStart(root, autoChk) {
  const path = autoChk.getAttribute("data-path");
  const colPath = path.replace(".AutoColumnStart", ".ColumnStart");
  const col = root.querySelector(`[data-path="${colPath}"]`);
  if (!col) return;

  col.disabled = !!autoChk.checked;
  col.placeholder = autoChk.checked ? "auto" : "";
  if (autoChk.checked) {
    col.value = "";
    setByPath(state, colPath, "");
  }
}

function handleColorPick(root, pick) {
  const txtId = pick.getAttribute("data-pick-for");
  const txt = root.querySelector(`#${CSS.escape(txtId)}`);
  if (!txt) return;
  txt.value = hexToRgb(pick.value);
  // dispara input manualmente para atualizar state + preview
  txt.dispatchEvent(new Event("input", { bubbles: true }));
}

function handleTextToPick(root, txt) {
  if (!txt.id) return;
  const pick = root.querySelector(`[data-pick-for="${CSS.escape(txt.id)}"]`);
  if (!pick) return;
  const hx = rgbToHex(txt.value);
  if (hx) pick.value = hx;
}

function ensureAtLeastOneKeymodeOn() {
  if (ALL_MANIA_KEYS.some((k) => state.maniaShared.enabled[k])) return;
  state.maniaShared.enabled[4] = true;
  state.maniaShared.open[4] = true;
}

/* ---------- ini generation ---------- */
function genIni() {
  const out = [];

  out.push("[General]");
  pushKV(out, "Name", state.general.Name);
  pushKV(out, "Author", state.general.Author);
  out.push(fmtKV("Version", state.version));

  // cursor options
  out.push(fmtKV("CursorRotate", bool01(!!state.general.CursorRotate)));
  out.push(fmtKV("CursorTrailRotate", bool01(!!state.general.CursorTrailRotate)));
  out.push(fmtKV("CursorExpand", bool01(!!state.general.CursorExpand)));
  out.push(fmtKV("CursorCentre", bool01(!!state.general.CursorCentre)));

  out.push("");

  if (state.exportMania) {
    for (const keys of ALL_MANIA_KEYS) {
      if (!state.maniaShared.enabled[keys]) continue;
      out.push("[Mania]");
      out.push(...genManiaBlock(keys));
      out.push("");
    }
  }

  while (out.length && out[out.length - 1] === "") out.pop();
  return out.join("\n");
}

function genManiaBlock(keys) {
  const m = state.mania[keys] || defaultManiaMode();
  const lines = [];

  lines.push(fmtKV("Keys", keys));
  spacer(lines);

  function normalizeCsv(raw, count, fallback) {
    const r = cleanLine(raw);
    if (!r) return fallback;
    if (r.includes(",")) return r;
    return Array.from({ length: count }, () => r).join(",");
  }

  lines.push(fmtKV("ColumnWidth", normalizeCsv(m.ColumnWidth, keys, Array.from({ length: keys }, () => "70").join(","))));
  lines.push(fmtKV("ColumnSpacing", normalizeCsv(m.ColumnSpacing, Math.max(0, keys - 1), Array.from({ length: Math.max(0, keys - 1) }, () => "0").join(","))));

  if (!m.AutoColumnStart) {
    pushKV(lines, "ColumnStart", m.ColumnStart);
  }
  pushKV(lines, "ColumnRight", m.ColumnRight);
  lines.push(fmtKV("ColumnLineWidth", normalizeCsv(m.ColumnLineWidth, keys + 1, Array.from({ length: keys + 1 }, () => "0").join(","))));
  spacer(lines);

  pushKV(lines, "HitPosition", m.HitPosition);
  pushKV(lines, "LightPosition", m.LightPosition);
  pushKV(lines, "ScorePosition", m.ScorePosition);
  pushKV(lines, "ComboPosition", m.ComboPosition);
  spacer(lines);

  lines.push(fmtKV("JudgementLine", bool01(!!m.JudgementLine)));
  lines.push(fmtKV("KeysUnderNotes", bool01(!!m.KeysUnderNotes)));
  lines.push(fmtKV("UpsideDown", bool01(!!m.UpsideDown)));
  spacer(lines);

  pushKV(lines, "BarlineHeight", m.BarlineHeight);
  pushKV(lines, "WidthForNoteHeightScale", m.WidthForNoteHeightScale);
  spacer(lines);

  header(lines, "colours");

  for (let ui = 1; ui <= keys; ui++) {
    const v = cleanLine(m.Colour?.[ui]);
    if (v) lines.push(fmtKV(`Colour${ui - 1}`, v));
    else if (state.commentEmpty) lines.push(state.pretty ? `// ${String(`Colour${ui - 1}`).padEnd(32, " ")} :` : `//Colour${ui - 1}:`);
  }
  spacer(lines);

  for (let ui = 1; ui <= keys; ui++) {
    const v = cleanLine(m.ColourLight?.[ui]);
    if (v) lines.push(fmtKV(`ColourLight${ui - 1}`, v));
    else if (state.commentEmpty) lines.push(state.pretty ? `// ${String(`ColourLight${ui - 1}`).padEnd(32, " ")} :` : `//ColourLight${ui - 1}:`);
  }

  pushKV(lines, "ColourColumnLine", m.ColourColumnLine);
  pushKV(lines, "ColourBarline", m.ColourBarline);
  pushKV(lines, "ColourJudgementLine", m.ColourJudgementLine);
  pushKV(lines, "ColourKeyWarning", m.ColourKeyWarning);
  pushKV(lines, "ColourHold", m.ColourHold);
  pushKV(lines, "ColourBreak", m.ColourBreak);

  spacer(lines);
  header(lines, "images");

  const pKey = m.pKey || "";
  const pKeyD = m.pKeyD || "";
  const pNote = m.pNote || "";
  const pNoteH = m.pNoteH || "";
  const pNoteL = m.pNoteL || "";
  const pNoteT = m.pNoteT || "";

  for (let idx = 0; idx < keys; idx++) {
    const n = idx + 1;
    const v = pat(pKey, n);
    if (v) lines.push(fmtKV(`KeyImage${idx}`, v));
    else if (state.commentEmpty) lines.push(state.pretty ? `// ${String(`KeyImage${idx}`).padEnd(32, " ")} :` : `//KeyImage${idx}:`);
  }
  spacer(lines);

  for (let idx = 0; idx < keys; idx++) {
    const n = idx + 1;
    const v = pat(pKeyD, n);
    if (v) lines.push(fmtKV(`KeyImage${idx}D`, v));
    else if (state.commentEmpty) lines.push(state.pretty ? `// ${String(`KeyImage${idx}D`).padEnd(32, " ")} :` : `//KeyImage${idx}D:`);
  }
  spacer(lines);

  for (let idx = 0; idx < keys; idx++) {
    const n = idx + 1;
    const v = pat(pNote, n);
    if (v) lines.push(fmtKV(`NoteImage${idx}`, v));
    else if (state.commentEmpty) lines.push(state.pretty ? `// ${String(`NoteImage${idx}`).padEnd(32, " ")} :` : `//NoteImage${idx}:`);
  }
  spacer(lines);

  for (let idx = 0; idx < keys; idx++) {
    const n = idx + 1;
    const v = pat(pNoteH, n);
    if (v) lines.push(fmtKV(`NoteImage${idx}H`, v));
    else if (state.commentEmpty) lines.push(state.pretty ? `// ${String(`NoteImage${idx}H`).padEnd(32, " ")} :` : `//NoteImage${idx}H:`);
  }
  spacer(lines);

  for (let idx = 0; idx < keys; idx++) {
    const n = idx + 1;
    const v = pat(pNoteL, n);
    if (v) lines.push(fmtKV(`NoteImage${idx}L`, v));
    else if (state.commentEmpty) lines.push(state.pretty ? `// ${String(`NoteImage${idx}L`).padEnd(32, " ")} :` : `//NoteImage${idx}L:`);
  }
  spacer(lines);

  for (let idx = 0; idx < keys; idx++) {
    const n = idx + 1;
    const v = pat(pNoteT, n);
    if (v) lines.push(fmtKV(`NoteImage${idx}T`, v));
    else if (state.commentEmpty) lines.push(state.pretty ? `// ${String(`NoteImage${idx}T`).padEnd(32, " ")} :` : `//NoteImage${idx}T:`);
  }
  spacer(lines);

  pushKV(lines, "WarningArrow", m.WarningArrow);

  while (lines.length && lines[lines.length - 1] === "") lines.pop();
  return lines;
}

/* ---------- import ---------- */
function parseIni(text) {
  const lines = String(text || "").split("\n");
  const parsed = { General: {}, Mania: [] };

  let section = "";
  let curMania = null;

  for (const raw of lines) {
    const line0 = raw.replace(/\r/g, "");
    const line = line0.trim();
    if (!line) continue;
    if (line.startsWith("//") || line.startsWith(";")) continue;

    const sec = line.match(/^\[(.+?)\]\s*$/);
    if (sec) {
      section = sec[1];
      if (section.toLowerCase() === "mania") {
        curMania = { Keys: null, kv: {} };
        parsed.Mania.push(curMania);
      } else {
        curMania = null;
      }
      continue;
    }

    let m = line.match(/^([A-Za-z0-9]+)\s*:\s*(.*)$/);
    if (!m) m = line.match(/^([A-Za-z0-9]+)\s*=\s*(.*)$/);
    if (!m) continue;

    const key = m[1];
    const val = (m[2] ?? "").trim();

    const secName = section.toLowerCase();
    if (secName === "general") parsed.General[key] = val;
    else if (secName === "mania" && curMania) {
      curMania.kv[key] = val;
      if (key === "Keys") {
        const k = parseInt(val, 10);
        curMania.Keys = Number.isFinite(k) ? k : null;
      }
    }
  }
  return parsed;
}

function applyParsed(parsed) {
  if (parsed.General.Version) state.version = parsed.General.Version;
  if ("Name" in parsed.General) state.general.Name = parsed.General.Name;
  if ("Author" in parsed.General) state.general.Author = parsed.General.Author;

  // General cursor bools
  for (const k of ["CursorRotate", "CursorTrailRotate", "CursorExpand", "CursorCentre"]) {
    if (k in parsed.General) state.general[k] = String(parsed.General[k]).trim() === "1";
  }

  for (const blk of parsed.Mania) {
    const keys = blk.Keys;
    if (!keys || keys < 1 || keys > 18) continue;

    state.maniaShared.enabled[keys] = true;
    state.maniaShared.open[keys] = true;

    const m = state.mania[keys] || defaultManiaMode();

    const direct = [
      "ColumnStart", "ColumnRight", "ColumnSpacing", "ColumnWidth", "ColumnLineWidth",
      "HitPosition", "LightPosition", "ScorePosition", "ComboPosition",
      "JudgementLine", "KeysUnderNotes", "UpsideDown",
      "BarlineHeight", "WidthForNoteHeightScale",
      "ColourColumnLine", "ColourBarline", "ColourJudgementLine", "ColourKeyWarning", "ColourHold", "ColourBreak",
      "WarningArrow"
    ];

    for (const k of direct) {
      if (k in blk.kv) {
        if (typeof m[k] === "boolean") m[k] = blk.kv[k].trim() === "1";
        else m[k] = blk.kv[k];
      }
    }

    m.AutoColumnStart = isBlank(m.ColumnStart);

    for (let i = 0; i < keys; i++) {
      const ck = `Colour${i}`;
      const lk = `ColourLight${i}`;
      if (ck in blk.kv) m.Colour[i + 1] = blk.kv[ck];
      if (lk in blk.kv) m.ColourLight[i + 1] = blk.kv[lk];
    }

    state.mania[keys] = m;
  }

  ensureAtLeastOneKeymodeOn();
  saveSoon(true);
  renderActiveTab();
}

/* ---------- save/load ---------- */
function saveState() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    $("savePulse").textContent = "Saved";
    setTimeout(() => { $("savePulse").textContent = "—"; }, 700);
  } catch (e) {
    $("savePulse").textContent = "ERR";
  }
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    const s = JSON.parse(raw);
    if (!s) return;

    // start clean, then merge carefully
    const base = makeDefaultState();

    base.activeTab = s.activeTab ?? base.activeTab;
    base.exportMania = (s.exportMania ?? true) ? true : false;
    base.pretty = (s.pretty ?? true) ? true : false;
    base.commentEmpty = (s.commentEmpty ?? false) ? true : false;
    base.version = s.version ?? base.version;

    Object.assign(base.general, s.general || {});

    // sanity for cursor fields (in case old storage)
    for (const k of ["CursorRotate", "CursorTrailRotate", "CursorExpand", "CursorCentre"]) {
      base.general[k] = !!base.general[k];
    }

    if (s.maniaShared) {
      for (const k of ALL_MANIA_KEYS) {
        base.maniaShared.enabled[k] = !!s.maniaShared.enabled?.[k];
        base.maniaShared.open[k] = !!s.maniaShared.open?.[k];
      }
      ensureAtLeastOneKeymodeOn();
    }

    if (s.mania) {
      for (const k of ALL_MANIA_KEYS) {
        if (s.mania[k]) base.mania[k] = { ...defaultManiaMode(), ...s.mania[k] };
      }
    }

    state = base;
  } catch (e) { /* ignore */ }
}

const saveSoon = debounce((force = false) => {
  saveState();
  if (force) updatePreview();
}, 300);

const previewSoon = debounce(() => updatePreview(), 70);

/* ---------- actions ---------- */
function updatePreview() {
  $("preview").value = genIni();
}

function downloadIni() {
  const text = $("preview").value || genIni();
  const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "skin.ini";
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

async function copyIni() {
  try {
    await navigator.clipboard.writeText($("preview").value || genIni());
    $("savePulse").textContent = "Copied";
    setTimeout(() => { $("savePulse").textContent = "—"; }, 800);
  } catch (e) {
    $("savePulse").textContent = "NoCopy";
    setTimeout(() => { $("savePulse").textContent = "—"; }, 800);
  }
}

function wipeAll() {
  if (!confirm("Full reset + clear autosave?")) return;
  try { localStorage.removeItem(STORAGE_KEY); } catch (e) {}
  location.reload();
}

function updateModeBadge() {
  const parts = ["GENERAL"];
  if (state.exportMania) parts.push("MANIA");
  $("modeBadge").textContent = "export: " + parts.join("+");
}

function syncDockToggles() {
  $("togMania").classList.toggle("active", state.exportMania);
  $("togPretty").classList.toggle("active", state.pretty);
  $("togCommentEmpty").classList.toggle("active", state.commentEmpty);
}

/* ---------- change pipeline ---------- */
function onAnyChange(skipSave = false) {
  previewSoon();
  if (!skipSave) saveSoon();
  updateModeBadge();
}

/* ---------- event wiring ---------- */
function wireDock() {
  document.querySelectorAll(".icoBtn[data-tab]").forEach((b) => {
    b.addEventListener("click", () => setActiveTab(b.dataset.tab));
  });

  $("togMania").addEventListener("click", () => {
    state.exportMania = !state.exportMania;
    syncDockToggles();
    onAnyChange();
    if (state.activeTab === "mania") renderActiveTab();
  });

  $("togPretty").addEventListener("click", () => {
    state.pretty = !state.pretty;
    syncDockToggles();
    onAnyChange();
  });

  $("togCommentEmpty").addEventListener("click", () => {
    state.commentEmpty = !state.commentEmpty;
    syncDockToggles();
    onAnyChange();
  });
}

function wireTopbar() {
  $("downloadIni").addEventListener("click", downloadIni);
  $("copyIni").addEventListener("click", copyIni);
  $("wipeAll").addEventListener("click", wipeAll);
  $("refresh").addEventListener("click", updatePreview);

  $("selectAll").addEventListener("click", () => {
    $("preview").focus();
    $("preview").select();
  });

  $("verBtn").addEventListener("click", () => {
    $("versionPick").value = state.version;
    $("verDlg").showModal();
  });

  $("versionPick").addEventListener("change", () => {
    state.version = $("versionPick").value;
    onAnyChange();
    renderActiveTab();
  });

  $("importOpen").addEventListener("click", () => {
    $("importArea").value = $("preview").value || "";
    $("importDlg").showModal();
  });

  $("importApply").addEventListener("click", () => {
    const parsed = parseIni($("importArea").value || "");
    applyParsed(parsed);
    $("importDlg").close();
  });
}

function wirePanelDelegation() {
  const panel = $("panel");

  // click: accordions
  panel.addEventListener("click", (e) => {
    const head = e.target.closest(".blockHead");
    if (!head || !panel.contains(head)) return;
    handleAccordionClick(panel, head);
  });

  // input/change: all inputs
  function handleInputEvent(e) {
    const t = e.target;

    // color pickers
    if (t && t.matches('input[type="color"][data-pick-for]')) {
      handleColorPick(panel, t);
      return;
    }

    // km toggles (enable/disable keymodes)
    if (t && t.classList && t.classList.contains("kmToggle")) {
      const k = Number(t.dataset.k);
      state.maniaShared.enabled[k] = !!t.checked;
      state.maniaShared.open[k] = !!t.checked;
      ensureAtLeastOneKeymodeOn();
      renderActiveTab();
      onAnyChange();
      return;
    }

    // data-path inputs
    if (t && t.dataset && t.dataset.path) {
      const path = t.dataset.path;
      const prev = getByPath(state, path);

      if (t.type === "checkbox") setByPath(state, path, !!t.checked);
      else setByPath(state, path, t.value);

      // AutoColumnStart special handling
      if (path.endsWith(".AutoColumnStart")) {
        syncColumnStart(panel, t);
      }

      // keep pick synced for color text fields
      if (t.type === "text") handleTextToPick(panel, t);

      // Avoid unnecessary spam if value didn't change (small perf)
      const next = getByPath(state, path);
      if (prev !== next) onAnyChange();
      return;
    }
  }

  panel.addEventListener("input", handleInputEvent);
  panel.addEventListener("change", handleInputEvent);
}

/* ---------- init ---------- */
function init() {
  loadState();
  syncDockToggles();
  renderDockActive();
  updateModeBadge();
  wireDock();
  wireTopbar();
  wirePanelDelegation();
  renderActiveTab();
  updatePreview();
}

init();
</script>
