<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Osu! Skin.ini Architect | Ultimate Edition</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-app: #050505;
            --bg-sidebar: #0a0a0a;
            --bg-panel: #0f0f0f;
            --bg-input: #141414;
            --bg-input-focus: #1a1a1a;
            
            --border: #222;
            --border-hover: #333;
            
            --primary: #ff0077; /* Osu Pink */
            --primary-dim: rgba(255, 0, 119, 0.1);
            --primary-glow: rgba(255, 0, 119, 0.4);
            
            --text-main: #ececec;
            --text-muted: #777;
            --text-desc: #555;

            --font-ui: 'Inter', system-ui, sans-serif;
            --font-code: 'JetBrains Mono', monospace;
            
            --ease: cubic-bezier(0.23, 1, 0.32, 1);
        }

        * { box-sizing: border-box; outline: none; }
        
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-app); }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--primary); }

        body {
            margin: 0;
            background: var(--bg-app);
            color: var(--text-main);
            font-family: var(--font-ui);
            height: 100vh;
            overflow: hidden;
            display: flex;
        }

        /* --- LAYOUT --- */
        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr 350px;
            width: 100%;
            height: 100%;
        }

        /* --- SIDEBAR --- */
        .sidebar {
            background: var(--bg-sidebar);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            padding: 0;
            user-select: none;
        }

        .brand {
            padding: 20px;
            font-size: 18px;
            font-weight: 700;
            letter-spacing: -0.02em;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .brand span { color: var(--primary); }
        .brand-ver { font-size: 10px; background: #222; padding: 2px 6px; border-radius: 4px; color: #888; margin-left: auto; }

        .nav-scroll {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .nav-category {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-desc);
            margin: 15px 10px 5px;
            font-weight: 600;
        }

        .nav-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 12px;
            margin-bottom: 2px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s var(--ease);
            color: var(--text-muted);
            font-size: 13px;
            font-weight: 500;
        }
        .nav-item:hover { background: var(--bg-input); color: var(--text-main); }
        .nav-item.active { background: var(--primary-dim); color: var(--primary); }
        .nav-item svg { width: 16px; height: 16px; opacity: 0.7; }
        .nav-item.active svg { opacity: 1; }

        .sidebar-footer {
            padding: 15px;
            border-top: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* --- MAIN EDITOR --- */
        .editor-area {
            background: var(--bg-panel);
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .editor-header {
            padding: 20px 30px;
            border-bottom: 1px solid var(--border);
            background: rgba(15,15,15,0.9);
            backdrop-filter: blur(10px);
            position: sticky; top: 0; z-index: 10;
            display: flex; justify-content: space-between; align-items: center;
        }
        .section-title h1 { margin: 0; font-size: 24px; font-weight: 700; }
        .section-title p { margin: 5px 0 0; color: var(--text-muted); font-size: 13px; }

        .editor-content {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            scroll-behavior: smooth;
        }

        /* --- FORM ELEMENTS --- */
        .form-group {
            margin-bottom: 25px;
            animation: slideIn 0.3s var(--ease);
        }
        @keyframes slideIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: 0; } }

        .group-header {
            font-size: 14px;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 15px;
            display: flex; align-items: center; gap: 10px;
        }
        .group-header::after { content:""; flex:1; height:1px; background: var(--border); }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }

        .control-item {
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            transition: 0.2s;
            position: relative;
        }
        .control-item:focus-within {
            border-color: var(--primary);
            background: var(--bg-input-focus);
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }

        .label-row {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 8px;
        }
        .control-label {
            font-size: 12px; font-weight: 600; color: var(--text-main);
        }
        .tooltip-trigger {
            color: var(--text-desc); cursor: help; font-size: 11px;
            border-bottom: 1px dotted var(--text-desc);
        }

        /* Inputs */
        input[type="text"], input[type="number"] {
            width: 100%;
            background: transparent;
            border: none;
            border-bottom: 1px solid var(--border);
            color: #fff;
            padding: 6px 0;
            font-family: var(--font-code);
            font-size: 13px;
            transition: 0.2s;
        }
        input:focus { border-bottom-color: var(--primary); }

        /* Color Picker */
        .color-widget {
            display: flex; gap: 8px; align-items: center;
        }
        .color-preview {
            width: 32px; height: 32px; border-radius: 6px;
            border: 1px solid var(--border);
            overflow: hidden; position: relative;
            cursor: pointer;
        }
        input[type="color"] {
            position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            cursor: pointer; padding: 0; margin: 0;
        }

        /* Switch */
        .switch-wrap {
            display: flex; justify-content: space-between; align-items: center;
            height: 100%;
        }
        .toggle-switch {
            position: relative; width: 40px; height: 20px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #333; border-radius: 20px; transition: .3s;
        }
        .slider:before {
            position: absolute; content: "";
            height: 14px; width: 14px; left: 3px; bottom: 3px;
            background-color: white; border-radius: 50%; transition: .3s;
        }
        input:checked + .slider { background-color: var(--primary); }
        input:checked + .slider:before { transform: translateX(20px); }

        /* --- PREVIEW PANE --- */
        .preview-pane {
            background: #080808;
            border-left: 1px solid var(--border);
            display: flex; flex-direction: column;
        }
        .preview-header {
            padding: 15px; border-bottom: 1px solid var(--border);
            font-size: 11px; font-weight: 700; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: 1px;
            display: flex; justify-content: space-between;
        }
        #previewCode {
            flex: 1; width: 100%; height: 100%;
            background: transparent; border: none;
            color: #a9b7c6;
            padding: 20px;
            font-family: var(--font-code);
            font-size: 12px; line-height: 1.5;
            resize: none;
        }

        /* Buttons */
        .btn {
            width: 100%; padding: 12px; border: none; border-radius: 6px;
            font-weight: 600; cursor: pointer; transition: 0.2s;
            display: flex; justify-content: center; align-items: center; gap: 8px;
        }
        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: #d90065; box-shadow: 0 4px 15px var(--primary-glow); }
        .btn-sec { background: transparent; border: 1px solid var(--border); color: var(--text-muted); }
        .btn-sec:hover { border-color: #555; color: #fff; background: rgba(255,255,255,0.05); }

        /* MANIA MATRIX */
        .mania-matrix {
            display: grid; grid-template-columns: repeat(6, 1fr); gap: 6px; margin-bottom: 20px;
        }
        .key-btn {
            background: var(--bg-input); border: 1px solid var(--border);
            padding: 8px; text-align: center; border-radius: 4px;
            font-size: 12px; cursor: pointer; transition: 0.2s;
        }
        .key-btn.active { background: var(--primary); border-color: var(--primary); color: #fff; }
        .key-btn:hover:not(.active) { border-color: #666; }

        .mania-block {
            border: 1px solid var(--border); background: rgba(255,255,255,0.02);
            margin-bottom: 10px; border-radius: 8px; overflow: hidden;
        }
        .mania-head {
            padding: 10px 15px; background: rgba(0,0,0,0.3);
            cursor: pointer; display: flex; justify-content: space-between;
            font-size: 12px; font-weight: 700;
        }
        .mania-head:hover { background: rgba(255,255,255,0.05); }
        .mania-body { padding: 15px; display: none; border-top: 1px solid var(--border); }
        .mania-block.open .mania-body { display: block; }
        
        /* Tooltip (Custom) */
        .desc-box {
            font-size: 11px; color: var(--text-desc); margin-top: 6px; line-height: 1.4;
            display: none;
        }
        .control-item:focus-within .desc-box { display: block; animation: fadeIn 0.2s; }
        @keyframes fadeIn { from {opacity:0} to {opacity:1}}

        @media (max-width: 1200px) { .app-container { grid-template-columns: 240px 1fr 0; } .preview-pane { display:none; } }
    </style>
</head>
<body>

<div class="app-container">
    <!-- SIDEBAR -->
    <aside class="sidebar">
        <div class="brand">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="var(--primary)"><circle cx="12" cy="12" r="10"/></svg>
            Skin<span>Arch</span> <span class="brand-ver">v3.0</span>
        </div>
        
        <div class="nav-scroll">
            <div class="nav-category">Core</div>
            <div class="nav-item active" onclick="renderSection('General')">
                <svg viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2"><path d="M12 20h9"/><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                General
            </div>
            <div class="nav-item" onclick="renderSection('Colours')">
                <svg viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"/></svg>
                Colours
            </div>
            <div class="nav-item" onclick="renderSection('Fonts')">
                <svg viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>
                Fonts
            </div>

            <div class="nav-category">Modes</div>
            <div class="nav-item" onclick="renderSection('Catch')">
                <svg viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
                Catch the Beat
            </div>
            <div class="nav-item" onclick="renderSection('Taiko')">
                <svg viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>
                Taiko
            </div>
            <div class="nav-item" onclick="renderSection('Mania')">
                <svg viewBox="0 0 24 24" stroke="currentColor" fill="none" stroke-width="2"><rect x="2" y="2" width="20" height="20" rx="2"/><path d="M7 2v20"/><path d="M17 2v20"/><path d="M2 12h20"/></svg>
                Mania (All Keys)
            </div>
        </div>

        <div class="sidebar-footer">
            <button class="btn btn-primary" onclick="downloadIni()">Download .INI</button>
            <button class="btn btn-sec" onclick="resetAll()">Reset Data</button>
        </div>
    </aside>

    <!-- EDITOR -->
    <main class="editor-area">
        <div class="editor-header">
            <div class="section-title">
                <h1 id="pageTitle">General</h1>
                <p id="pageDesc">Basic metadata and cursor behaviour.</p>
            </div>
        </div>
        <div id="editorContent" class="editor-content">
            <!-- Dynamic Content Injected Here -->
        </div>
    </main>

    <!-- PREVIEW -->
    <aside class="preview-pane">
        <div class="preview-header">
            <span>Live Preview</span>
            <span id="saveStatus" style="color:var(--primary)">Saved</span>
        </div>
        <textarea id="previewCode" readonly spellcheck="false"></textarea>
    </aside>
</div>

<script>
/**
 * OSU! SKIN ARCHITECT - ULTIMATE SCHEMA
 * Defines structure, defaults, types, and wiki tooltips for the entire interface.
 */
const SCHEMA = {
    General: {
        _desc: "Metadata, cursor settings, and global behavior.",
        Meta: [
            { id: "Name", type: "string", def: "My Skin", tip: "The name of the skin." },
            { id: "Author", type: "string", def: "Unknown", tip: "The creator of the skin." },
            { id: "Version", type: "string", def: "latest", tip: "Skin version. Use 'latest' for best compatibility." },
        ],
        Cursor: [
            { id: "CursorCentre", type: "bool", def: true, tip: "If set to 1, the cursor's active point is the center of the image." },
            { id: "CursorExpand", type: "bool", def: true, tip: "If 1, cursor expands when clicked." },
            { id: "CursorRotate", type: "bool", def: true, tip: "If 1, cursor rotates constantly." },
            { id: "CursorTrailRotate", type: "bool", def: true, tip: "If 1, the trail rotates with the cursor." },
        ],
        Gameplay: [
            { id: "AnimationFramerate", type: "int", def: -1, tip: "Frame rate for animated elements. -1 ignores frame limiting." },
            { id: "AllowSliderBallTint", type: "bool", def: true, tip: "Tint the slider ball with the combo color." },
            { id: "ComboBurstRandom", type: "bool", def: false, tip: "Show combo bursts in random order." },
            { id: "HitCircleOverlayAboveNumber", type: "bool", def: true, tip: "Draws the overlay image above the hit number." },
            { id: "LayeredHitSounds", type: "bool", def: true, tip: "Allows multiple hitsounds to play at once." },
            { id: "SliderBallFlip", type: "bool", def: true, tip: "Flips the slider ball image when reversing." },
            { id: "SpinnerFadePlayfield", type: "bool", def: false, tip: "Darkens the playfield when spinning." },
            { id: "SpinnerNoBlink", type: "bool", def: false, tip: "Disables the blinking gauge on spinners." },
        ]
    },
    Colours: {
        _desc: "Defines the color palette for gameplay and interface.",
        Combos: [
            { id: "Combo1", type: "color", def: "255,192,0", tip: "First combo color." },
            { id: "Combo2", type: "color", def: "0,202,0", tip: "Second combo color." },
            { id: "Combo3", type: "color", def: "18,124,255", tip: "Third combo color." },
            { id: "Combo4", type: "color", def: "242,24,57", tip: "Fourth combo color." },
            { id: "Combo5", type: "color", def: "", tip: "Optional 5th color." },
            { id: "Combo6", type: "color", def: "", tip: "Optional 6th color." },
            { id: "Combo7", type: "color", def: "", tip: "Optional 7th color." },
            { id: "Combo8", type: "color", def: "", tip: "Optional 8th color." },
        ],
        Sliders: [
            { id: "SliderBorder", type: "color", def: "255,255,255", tip: "Color of the slider's white border." },
            { id: "SliderTrackOverride", type: "color", def: "0,0,0", tip: "Overrides the inner track color. If black, uses combo color." },
        ],
        Spinner: [
            { id: "SpinnerApproachCircle", type: "color", def: "77,139,217", tip: "Color of the approach circle closing in on spinner." },
            { id: "SpinnerBackground", type: "color", def: "100,100,100", tip: "Tint for the spinner background element." },
        ],
        Interface: [
            { id: "MenuGlow", type: "color", def: "0,78,155", tip: "Glow color in the main menu." },
            { id: "SongSelectActiveText", type: "color", def: "0,0,0", tip: "Text color for the selected song." },
            { id: "SongSelectInactiveText", type: "color", def: "255,255,255", tip: "Text color for unselected songs." },
            { id: "InputOverlayText", type: "color", def: "0,0,0", tip: "Color of the key usage overlay text." },
        ]
    },
    Fonts: {
        _desc: "Prefixes and spacing for numbers.",
        HitCircle: [
            { id: "HitCirclePrefix", type: "string", def: "default", tip: "Prefix for hit circle number images." },
            { id: "HitCircleOverlap", type: "int", def: -2, tip: "How many pixels numbers overlap on hit circles." },
        ],
        Score: [
            { id: "ScorePrefix", type: "string", def: "score", tip: "Prefix for the main score numbers." },
            { id: "ScoreOverlap", type: "int", def: 0, tip: "Overlap for score numbers." },
        ],
        Combo: [
            { id: "ComboPrefix", type: "string", def: "score", tip: "Prefix for combo counter numbers." },
            { id: "ComboOverlap", type: "int", def: 0, tip: "Overlap for combo numbers." },
        ]
    },
    Catch: {
        _desc: "Configuration for Catch the Beat (Fruits).",
        Catcher: [
            { id: "HyperDash", type: "color", def: "255,0,0", tip: "Color of the catcher when hyperdashing." },
            { id: "HyperDashAfterImage", type: "color", def: "255,0,0", tip: "Color of the trail left during hyperdash." },
            { id: "HyperDashFruit", type: "color", def: "255,0,0", tip: "Outline color of a hyperdash fruit." },
        ],
        Fruits: [
            { id: "FruitApple", type: "string", def: "fruit-apple", tip: "Image prefix for apple." },
            { id: "FruitBananas", type: "string", def: "fruit-bananas", tip: "Image prefix for bananas." },
            { id: "FruitGrapes", type: "string", def: "fruit-grapes", tip: "Image prefix for grapes." },
            { id: "FruitPear", type: "string", def: "fruit-pear", tip: "Image prefix for pear." },
            { id: "FruitOrange", type: "string", def: "fruit-orange", tip: "Image prefix for orange." },
        ]
    },
    Taiko: {
        _desc: "Configuration for Taiko mode.",
        DrumRoll: [
            { id: "DrumRollMain", type: "color", def: "255,255,255", tip: "Main color of the drum roll slider." },
            { id: "DrumRollGong", type: "color", def: "255,255,255", tip: "Color of the drum roll ticks." },
            { id: "DrumRollLight", type: "color", def: "255,255,255", tip: "Color of the border/highlight." },
        ],
        Assets: [
            { id: "TaikoHitCircle", type: "string", def: "taikohitcircle", tip: "Filename for Don/Kat." },
            { id: "TaikoHitCircleOverlay", type: "string", def: "taikohitcircleoverlay", tip: "Overlay for Don/Kat." },
            { id: "TaikoBigHitCircle", type: "string", def: "taikobighitcircle", tip: "Filename for Big Don/Kat." },
            { id: "TaikoBigHitCircleOverlay", type: "string", def: "taikobighitcircleoverlay", tip: "Overlay for Big Don/Kat." },
        ]
    }
    /* Mania is handled specially due to dynamic keys */
};

// Global State
let STATE = {};
let MANIA_KEYS = new Set([4, 7]); // Default active
let CURRENT_TAB = 'General';

// --- UTILS ---

const $ = (id) => document.getElementById(id);

function rgbToHex(rgb) {
    if(!rgb) return "#000000";
    const parts = rgb.split(',').map(Number);
    if(parts.length < 3) return "#000000";
    return "#" + parts.map(c => Math.max(0, Math.min(255, c)).toString(16).padStart(2, "0")).join("");
}

function hexToRgb(hex) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return `${r},${g},${b}`;
}

// --- BUILDER ENGINE ---

function init() {
    // 1. Load state from local storage or defaults
    const saved = localStorage.getItem('osu_skin_architect_v3');
    if (saved) {
        try {
            const data = JSON.parse(saved);
            STATE = data.state;
            if(data.mania) MANIA_KEYS = new Set(data.mania);
        } catch(e) { console.error("Save corrupted"); }
    }
    
    // 2. Hydrate missing state from SCHEMA
    for(let section in SCHEMA) {
        for(let group in SCHEMA[section]) {
            if(group === '_desc') continue;
            SCHEMA[section][group].forEach(item => {
                if(STATE[item.id] === undefined) STATE[item.id] = item.def;
            });
        }
    }
    
    // 3. Render
    renderSection('General');
    updatePreview();
}

function renderSection(sectionName) {
    CURRENT_TAB = sectionName;
    const container = $('editorContent');
    const title = $('pageTitle');
    const desc = $('pageDesc');
    
    // UI Update
    document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
    // Approximate active class logic for simplicity
    const navItems = document.querySelectorAll('.nav-item');
    if(sectionName === 'General') navItems[0].classList.add('active');
    else if(sectionName === 'Colours') navItems[1].classList.add('active');
    else if(sectionName === 'Fonts') navItems[2].classList.add('active');
    else if(sectionName === 'Catch') navItems[3].classList.add('active');
    else if(sectionName === 'Taiko') navItems[4].classList.add('active');
    else if(sectionName === 'Mania') navItems[5].classList.add('active');

    container.innerHTML = '';
    title.textContent = sectionName;

    // MANIA SPECIAL RENDERING
    if(sectionName === 'Mania') {
        desc.textContent = "Configure per-keymode settings (1K - 18K).";
        renderManiaTools(container);
        renderManiaBlocks(container);
        return;
    }

    // STANDARD SCHEMA RENDERING
    const schemaData = SCHEMA[sectionName];
    desc.textContent = schemaData._desc;

    for(let groupName in schemaData) {
        if(groupName === '_desc') continue;
        
        const groupEl = document.createElement('div');
        groupEl.className = 'form-group';
        
        const head = document.createElement('div');
        head.className = 'group-header';
        head.textContent = groupName;
        groupEl.appendChild(head);

        const grid = document.createElement('div');
        grid.className = 'control-grid';

        schemaData[groupName].forEach(field => {
            grid.appendChild(createControl(field));
        });

        groupEl.appendChild(grid);
        container.appendChild(groupEl);
    }
}

function createControl(field) {
    const wrap = document.createElement('div');
    wrap.className = 'control-item';

    // Label Row
    const labelRow = document.createElement('div');
    labelRow.className = 'label-row';
    
    const label = document.createElement('div');
    label.className = 'control-label';
    label.textContent = field.id;
    labelRow.appendChild(label);
    
    // Tooltip trigger (icon)
    const tip = document.createElement('span');
    tip.className = 'tooltip-trigger';
    tip.textContent = '?';
    tip.title = field.tip; // Native title for fallback
    labelRow.appendChild(tip);

    wrap.appendChild(labelRow);

    // Input Element
    let inputEl;

    if (field.type === 'bool') {
        const switchWrap = document.createElement('div');
        switchWrap.className = 'switch-wrap';
        
        const toggle = document.createElement('label');
        toggle.className = 'toggle-switch';
        
        const chk = document.createElement('input');
        chk.type = 'checkbox';
        chk.checked = !!STATE[field.id];
        chk.onchange = (e) => {
            STATE[field.id] = e.target.checked;
            updatePreview();
        };
        
        const slider = document.createElement('span');
        slider.className = 'slider';
        
        toggle.appendChild(chk);
        toggle.appendChild(slider);
        switchWrap.appendChild(toggle);
        wrap.appendChild(switchWrap);

    } else if (field.type === 'color') {
        const cWidget = document.createElement('div');
        cWidget.className = 'color-widget';
        
        const cPreview = document.createElement('div');
        cPreview.className = 'color-preview';
        cPreview.style.backgroundColor = rgbToHex(STATE[field.id] || field.def);
        
        const cInput = document.createElement('input');
        cInput.type = 'color';
        cInput.value = rgbToHex(STATE[field.id] || field.def);
        
        // Text Input
        const tInput = document.createElement('input');
        tInput.type = 'text';
        tInput.value = STATE[field.id] || field.def;
        
        // Sync Logic
        cInput.oninput = (e) => {
            const rgb = hexToRgb(e.target.value);
            tInput.value = rgb;
            cPreview.style.backgroundColor = e.target.value;
            STATE[field.id] = rgb;
            updatePreview();
        };
        
        tInput.oninput = (e) => {
            STATE[field.id] = e.target.value;
            const hex = rgbToHex(e.target.value);
            cInput.value = hex;
            cPreview.style.backgroundColor = hex;
            updatePreview();
        };

        cPreview.appendChild(cInput);
        cWidget.appendChild(cPreview);
        cWidget.appendChild(tInput);
        wrap.appendChild(cWidget);

    } else {
        // String or Int
        inputEl = document.createElement('input');
        inputEl.type = field.type === 'int' ? 'number' : 'text';
        inputEl.value = STATE[field.id] !== undefined ? STATE[field.id] : field.def;
        inputEl.oninput = (e) => {
            STATE[field.id] = e.target.value;
            updatePreview();
        };
        wrap.appendChild(inputEl);
    }

    // Tooltip Description Box
    const descBox = document.createElement('div');
    descBox.className = 'desc-box';
    descBox.textContent = field.tip;
    wrap.appendChild(descBox);

    return wrap;
}

// --- MANIA SPECIAL HANDLING ---

function renderManiaTools(container) {
    const box = document.createElement('div');
    box.className = 'form-group';
    box.innerHTML = `<div class="group-header">Active Key Modes</div>`;
    
    const grid = document.createElement('div');
    grid.className = 'mania-matrix';
    
    for(let i=1; i<=18; i++) {
        const btn = document.createElement('div');
        btn.className = `key-btn ${MANIA_KEYS.has(i) ? 'active' : ''}`;
        btn.textContent = i + 'K';
        btn.onclick = () => {
            if(MANIA_KEYS.has(i)) MANIA_KEYS.delete(i);
            else MANIA_KEYS.add(i);
            renderSection('Mania'); // Re-render to show/hide blocks
            updatePreview();
        };
        grid.appendChild(btn);
    }
    box.appendChild(grid);
    container.appendChild(box);
}

function renderManiaBlocks(container) {
    const sortedKeys = Array.from(MANIA_KEYS).sort((a,b)=>a-b);
    
    if(sortedKeys.length === 0) {
        container.innerHTML += `<div style="text-align:center; color:#555; padding:20px;">No keymodes active. Select some above.</div>`;
        return;
    }

    sortedKeys.forEach(k => {
        const block = document.createElement('div');
        block.className = 'mania-block';
        
        // Header
        const head = document.createElement('div');
        head.className = 'mania-head';
        head.innerHTML = `<span>${k}K Settings</span><span>â–¼</span>`;
        head.onclick = () => block.classList.toggle('open');
        
        // Body
        const body = document.createElement('div');
        body.className = 'mania-body control-grid';
        
        // Define Mania Fields dynamically per key
        const fields = [
            { id: `ColumnStart_${k}`, label: "ColumnStart", def: "136", type: "int" },
            { id: `ColumnWidth_${k}`, label: "ColumnWidth", def: "30,30,30...", type: "string" },
            { id: `HitPosition_${k}`, label: "HitPosition", def: "402", type: "int" },
            { id: `SpecialStyle_${k}`, label: "SpecialStyle", def: false, type: "bool" },
            { id: `UpsideDown_${k}`, label: "UpsideDown", def: false, type: "bool" },
            { id: `JudgementLine_${k}`, label: "JudgementLine", def: true, type: "bool" },
            { id: `StageHint_${k}`, label: "StageHint", def: "", type: "string" },
            { id: `StageLeft_${k}`, label: "StageLeft", def: "", type: "string" },
        ];

        fields.forEach(f => {
            // Simplified createControl for mania dynamic keys
            // In a full 5k line version, this would be more abstracted
            // Creating a mock field object to reuse createControl logic? No, easier to manual here for dynamic ID
            
            const fieldKey = f.id; 
            
            const wrap = document.createElement('div');
            wrap.className = 'control-item';
            
            // Label
            const lRow = document.createElement('div');
            lRow.className = 'label-row';
            lRow.innerHTML = `<div class="control-label">${f.label}</div>`;
            wrap.appendChild(lRow);

            if(f.type === 'bool') {
                 const sw = document.createElement('div'); sw.className='switch-wrap';
                 const tg = document.createElement('label'); tg.className='toggle-switch';
                 const inp = document.createElement('input'); inp.type='checkbox';
                 inp.checked = STATE[fieldKey] !== undefined ? STATE[fieldKey] : f.def;
                 inp.onchange = (e) => { STATE[fieldKey] = e.target.checked; updatePreview(); };
                 const sl = document.createElement('span'); sl.className='slider';
                 tg.appendChild(inp); tg.appendChild(sl); sw.appendChild(tg); wrap.appendChild(sw);
            } else {
                 const inp = document.createElement('input'); 
                 inp.type = f.type==='int'?'number':'text';
                 inp.value = STATE[fieldKey] !== undefined ? STATE[fieldKey] : f.def;
                 inp.oninput = (e) => { STATE[fieldKey] = e.target.value; updatePreview(); };
                 wrap.appendChild(inp);
            }
            body.appendChild(wrap);
        });

        block.appendChild(head);
        block.appendChild(body);
        container.appendChild(block);
    });
}

// --- GENERATOR CORE ---

function updatePreview() {
    const lines = [];
    
    // [General]
    lines.push("[General]");
    SCHEMA.General.Meta.forEach(f => lines.push(`${f.id}: ${STATE[f.id]||f.def}`));
    SCHEMA.General.Cursor.forEach(f => lines.push(`${f.id}: ${STATE[f.id] ? 1 : 0}`));
    SCHEMA.General.Gameplay.forEach(f => {
        let val = STATE[f.id];
        if(val === undefined) val = f.def;
        if(typeof val === 'boolean') val = val ? 1 : 0;
        if(val !== "") lines.push(`${f.id}: ${val}`);
    });
    lines.push("");

    // [Colours]
    lines.push("[Colours]");
    const colList = [...SCHEMA.Colours.Combos, ...SCHEMA.Colours.Sliders, ...SCHEMA.Colours.Spinner, ...SCHEMA.Colours.Interface];
    colList.forEach(f => {
        const val = STATE[f.id];
        if(val && val !== "") lines.push(`${f.id}: ${val}`);
    });
    lines.push("");

    // [Fonts]
    lines.push("[Fonts]");
    const fontList = [...SCHEMA.Fonts.HitCircle, ...SCHEMA.Fonts.Score, ...SCHEMA.Fonts.Combo];
    fontList.forEach(f => {
        const val = STATE[f.id];
        if(val !== undefined && val !== "") lines.push(`${f.id}: ${val}`);
    });
    lines.push("");

    // [CatchTheBeat]
    lines.push("[CatchTheBeat]");
    const ctbList = [...SCHEMA.Catch.Catcher, ...SCHEMA.Catch.Fruits];
    ctbList.forEach(f => {
        const val = STATE[f.id];
        if(val !== undefined && val !== "") lines.push(`${f.id}: ${val}`);
    });
    lines.push("");

    // [Taiko]
    lines.push("[Taiko]");
    const taikoList = [...SCHEMA.Taiko.DrumRoll, ...SCHEMA.Taiko.Assets];
    taikoList.forEach(f => {
        const val = STATE[f.id];
        if(val !== undefined && val !== "") lines.push(`${f.id}: ${val}`);
    });
    lines.push("");

    // [Mania]
    Array.from(MANIA_KEYS).sort((a,b)=>a-b).forEach(k => {
        lines.push("[Mania]");
        lines.push(`Keys: ${k}`);
        // Extract basic mania keys
        const mFields = ["ColumnStart", "ColumnWidth", "HitPosition", "SpecialStyle", "UpsideDown", "JudgementLine", "StageHint", "StageLeft"];
        mFields.forEach(mf => {
            let val = STATE[`${mf}_${k}`];
            if(val !== undefined) {
                if(typeof val === 'boolean') val = val ? 1 : 0;
                if(val !== "") lines.push(`${mf}: ${val}`);
            }
        });
        lines.push("");
    });

    const code = lines.join("\n");
    $('previewCode').value = code;
    
    // Autosave
    localStorage.setItem('osu_skin_architect_v3', JSON.stringify({
        state: STATE,
        mania: Array.from(MANIA_KEYS)
    }));
    
    const saveStat = $('saveStatus');
    saveStat.style.opacity = 1;
    setTimeout(() => saveStat.style.opacity = 0.5, 500);
}

function downloadIni() {
    const element = document.createElement('a');
    element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent($('previewCode').value));
    element.setAttribute('download', 'skin.ini');
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
}

function resetAll() {
    if(confirm("Reset all data to defaults?")) {
        localStorage.removeItem('osu_skin_architect_v3');
        STATE = {};
        MANIA_KEYS = new Set([4, 7]);
        init();
    }
}

// Start
init();

</script>
</body>
</html>
